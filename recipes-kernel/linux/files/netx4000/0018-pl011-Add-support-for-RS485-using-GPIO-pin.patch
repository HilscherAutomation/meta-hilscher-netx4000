From 873809a156fbea393e93ba8569899e7ca6ee2b02 Mon Sep 17 00:00:00 2001
From: Michael Trensch <mtrensch@hilscher.com>
Date: Mon, 14 Feb 2022 10:21:22 +0100
Subject: [PATCH 18/27] pl011: Add support for RS485 using GPIO pin

Upstream-Status: Pending
---
 drivers/tty/serial/amba-pl011.c | 42 ++++++++++++++++++++++++++-------
 1 file changed, 33 insertions(+), 9 deletions(-)
 mode change 100644 => 100755 drivers/tty/serial/amba-pl011.c

diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
old mode 100644
new mode 100755
index cd3913b933c7..dc71368be48f
--- a/drivers/tty/serial/amba-pl011.c
+++ b/drivers/tty/serial/amba-pl011.c
@@ -41,6 +41,7 @@
 #include <linux/sizes.h>
 #include <linux/io.h>
 #include <linux/acpi.h>
+#include <linux/of_gpio.h>
 
 #define UART_NR			14
 
@@ -272,6 +273,7 @@ struct uart_amba_port {
 	struct pl011_dmatx_data	dmatx;
 	bool			dma_probed;
 #endif
+	struct gpio_desc *rs485_txen_gpio;
 };
 
 static unsigned int pl011_tx_empty(struct uart_port *port);
@@ -1306,12 +1308,19 @@ static void pl011_rs485_tx_stop(struct uart_amba_port *uap)
 	if (port->rs485.delay_rts_after_send)
 		mdelay(port->rs485.delay_rts_after_send);
 
-	cr = pl011_read(uap, REG_CR);
+	if (uap->rs485_txen_gpio) {
+		if (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
+			gpiod_set_value_cansleep(uap->rs485_txen_gpio, 1);
+		else
+			gpiod_set_value_cansleep(uap->rs485_txen_gpio, 0);
+	} else {
+		cr = pl011_read(uap, REG_CR);
 
-	if (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
-		cr &= ~UART011_CR_RTS;
-	else
-		cr |= UART011_CR_RTS;
+		if (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
+			cr &= ~UART011_CR_RTS;
+		else
+			cr |= UART011_CR_RTS;
+	}
 
 	/* Disable the transmitter and reenable the transceiver */
 	cr &= ~UART011_CR_TXE;
@@ -1444,10 +1453,17 @@ static void pl011_rs485_tx_start(struct uart_amba_port *uap)
 	if (!(port->rs485.flags & SER_RS485_RX_DURING_TX))
 		cr &= ~UART011_CR_RXE;
 
-	if (port->rs485.flags & SER_RS485_RTS_ON_SEND)
-		cr &= ~UART011_CR_RTS;
-	else
-		cr |= UART011_CR_RTS;
+	if (uap->rs485_txen_gpio) {
+		if (port->rs485.flags & SER_RS485_RTS_ON_SEND)
+			gpiod_set_value_cansleep(uap->rs485_txen_gpio, 1);
+		else
+			gpiod_set_value_cansleep(uap->rs485_txen_gpio, 0);
+	} else {
+		if (port->rs485.flags & SER_RS485_RTS_ON_SEND)
+			cr &= ~UART011_CR_RTS;
+		else
+			cr |= UART011_CR_RTS;
+	}
 
 	pl011_write(cr, uap, REG_CR);
 
@@ -2736,6 +2752,14 @@ static int pl011_setup_port(struct device *dev, struct uart_amba_port *uap,
 
 	index = pl011_probe_dt_alias(index, dev);
 
+	uap->rs485_txen_gpio = devm_gpiod_get_optional(dev, "rs485-txen-gpio", GPIOD_ASIS);
+	if (uap->rs485_txen_gpio) {	
+		gpiod_direction_output(uap->rs485_txen_gpio, 0);
+		dev_info(dev, "gpio%d used as tx-enable for RS485 mode (active-%s)\n",
+		         desc_to_gpio(uap->rs485_txen_gpio),
+				 gpiod_is_active_low(uap->rs485_txen_gpio) ? "low" : "high");
+	}
+
 	uap->port.dev = dev;
 	uap->port.mapbase = mmiobase->start;
 	uap->port.membase = base;
-- 
2.25.1

