From 46e1ee56941d0ec1d4ab56555d9e1263ef4ffdb4 Mon Sep 17 00:00:00 2001
From: Michael Trensch <mtrensch@hilscher.com>
Date: Fri, 10 Sep 2021 11:07:18 +0000
Subject: [PATCH 05/27] gpio: Add GPIO driver for Hilscher netX4000 based
 platforms.

Upstream-Status: Pending
---
 drivers/gpio/Kconfig         |  11 ++
 drivers/gpio/Makefile        |   1 +
 drivers/gpio/gpio-netx4000.c | 344 +++++++++++++++++++++++++++++++++++
 3 files changed, 356 insertions(+)
 create mode 100644 drivers/gpio/gpio-netx4000.c

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 673bafb8be58..592fb392425b 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -478,6 +478,17 @@ config GPIO_MXS
 	select GPIO_GENERIC
 	select GENERIC_IRQ_CHIP
 
+config GPIO_NETX4000
+	tristate "GPIO driver for netX4000 based platforms"
+	depends on ARCH_NETX4000
+	select GPIOLIB_IRQCHIP
+	default y
+	help
+	  This selects GPIO support on Hilscher netX4000 based platforms.
+
+	  To compile this driver as a module, choose M here:
+	  the module will be called gpio-netx4000.
+
 config GPIO_OCTEON
 	tristate "Cavium OCTEON GPIO"
 	depends on CAVIUM_OCTEON_SOC
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index eb73b5d633eb..c6db8be847a4 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -116,6 +116,7 @@ obj-$(CONFIG_GPIO_MT7621)		+= gpio-mt7621.o
 obj-$(CONFIG_GPIO_MVEBU)		+= gpio-mvebu.o
 obj-$(CONFIG_GPIO_MXC)			+= gpio-mxc.o
 obj-$(CONFIG_GPIO_MXS)			+= gpio-mxs.o
+obj-$(CONFIG_GPIO_NETX4000)		+= gpio-netx4000.o
 obj-$(CONFIG_GPIO_OCTEON)		+= gpio-octeon.o
 obj-$(CONFIG_GPIO_OMAP)			+= gpio-omap.o
 obj-$(CONFIG_GPIO_PALMAS)		+= gpio-palmas.o
diff --git a/drivers/gpio/gpio-netx4000.c b/drivers/gpio/gpio-netx4000.c
new file mode 100644
index 000000000000..b799aa5d701f
--- /dev/null
+++ b/drivers/gpio/gpio-netx4000.c
@@ -0,0 +1,345 @@
+/*
+* GPIO driver for Hilscher netx4000 based platforms
+*
+* drivers/gpio/gpio-netx4000.c
+*
+* (C) Copyright 2016 Hilscher Gesellschaft fuer Systemautomation mbH
+* http://www.hilscher.com
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of
+* the License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+*/
+
+#define DRIVER_DESC  "GPIO driver for Hilscher netx4000 based platforms"
+#define DRIVER_NAME  "gpio-netx4000"
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+
+#define NETX4000_GPIO_MAX_NGPIO	(32)
+
+#define NETX4000_GPIO_IN	(0x00)
+#define NETX4000_GPIO_OUT	(0x08)
+#define NETX4000_GPIO_OE	(0x18)
+#define NETX4000_GPIO_IRQ_SRC	(0x1C)
+#define NETX4000_GPIO_IRQ_PEDGE	(0x20)
+#define NETX4000_GPIO_IRQ_NEDGE	(0x24)
+#define NETX4000_GPIO_OUT_SET	(0x28)
+#define NETX4000_GPIO_OUT_CLR	(0x2C)
+#define NETX4000_GPIO_OE_SET	(0x30)
+#define NETX4000_GPIO_OE_CLR	(0x34)
+
+struct netx4000_gpio_chip {
+	struct gpio_chip chip;
+	void __iomem *base;
+
+	/* irq handling stuff */
+	spinlock_t gpio_lock;
+	int irq;
+	u32 posedge_enable;
+	u32 negedge_enable;
+	u32 irq_enabled;
+};
+
+static void netx4000_gpio_irq_handler(struct irq_desc *desc)
+{
+    struct gpio_chip *gc = irq_desc_get_handler_data(desc);
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	int i;
+	unsigned long status;
+
+	chained_irq_enter(chip, desc);
+
+	status = readl(netx4000_gc->base + NETX4000_GPIO_IRQ_SRC);
+	writel(status, netx4000_gc->base + NETX4000_GPIO_IRQ_SRC);
+
+	for_each_set_bit(i, &status, netx4000_gc->chip.ngpio)
+		generic_handle_domain_irq(gc->irq.domain,
+                                  i);
+
+	chained_irq_exit(chip, desc);
+}
+
+static void netx4000_gpio_irq_unmask(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+	unsigned offset;
+	unsigned long flags;
+
+	offset = d->hwirq;
+
+	spin_lock_irqsave(&netx4000_gc->gpio_lock, flags);
+	writel(netx4000_gc->posedge_enable,
+		netx4000_gc->base + NETX4000_GPIO_IRQ_PEDGE);
+	writel(netx4000_gc->negedge_enable,
+		netx4000_gc->base + NETX4000_GPIO_IRQ_NEDGE);
+
+	netx4000_gc->irq_enabled |= (1 << offset);
+	spin_unlock_irqrestore(&netx4000_gc->gpio_lock, flags);
+}
+
+static void netx4000_gpio_irq_mask(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+	unsigned offset;
+	unsigned long flags;
+
+	offset = d->hwirq;
+
+	spin_lock_irqsave(&netx4000_gc->gpio_lock, flags);
+	writel(netx4000_gc->posedge_enable & ~(1 << offset),
+		netx4000_gc->base + NETX4000_GPIO_IRQ_PEDGE);
+	writel(netx4000_gc->negedge_enable & ~(1 << offset),
+		netx4000_gc->base + NETX4000_GPIO_IRQ_NEDGE);
+
+	netx4000_gc->irq_enabled &= ~(1 << offset);
+	spin_unlock_irqrestore(&netx4000_gc->gpio_lock, flags);
+}
+
+static int netx4000_gpio_irq_set_type(struct irq_data *d, unsigned int type)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+	unsigned offset;
+	unsigned long flags;
+	int ret = 0;
+
+	offset = d->hwirq;
+
+	spin_lock_irqsave(&netx4000_gc->gpio_lock, flags);
+	switch(type) {
+	case IRQ_TYPE_NONE:
+		netx4000_gc->posedge_enable &= ~(1 << offset);
+		netx4000_gc->negedge_enable &= ~(1 << offset);
+		break;
+
+	case IRQ_TYPE_EDGE_RISING:
+		netx4000_gc->posedge_enable |= (1 << offset);
+		netx4000_gc->negedge_enable &= ~(1 << offset);
+		break;
+
+	case IRQ_TYPE_EDGE_FALLING:
+		netx4000_gc->posedge_enable &= ~(1 << offset);
+		netx4000_gc->negedge_enable |= (1 << offset);
+		break;
+
+	case IRQ_TYPE_EDGE_BOTH:
+		netx4000_gc->posedge_enable |= (1 << offset);
+		netx4000_gc->negedge_enable |= (1 << offset);
+		break;
+
+	case IRQ_TYPE_LEVEL_HIGH:
+	case IRQ_TYPE_LEVEL_LOW:
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock_irqrestore(&netx4000_gc->gpio_lock, flags);
+
+	return ret;
+}
+
+static const struct irq_chip netx4000_gpio_irq_chip = {
+        .name           = "gpio-rcar",
+        .irq_mask       = netx4000_gpio_irq_mask,
+        .irq_unmask     = netx4000_gpio_irq_unmask,
+        .irq_set_type   = netx4000_gpio_irq_set_type,
+        .flags          = IRQCHIP_IMMUTABLE | IRQCHIP_SET_TYPE_MASKED |
+                          IRQCHIP_MASK_ON_SUSPEND,
+        GPIOCHIP_IRQ_RESOURCE_HELPERS,
+};
+
+static int netx4000_gpio_get(struct gpio_chip *gc, unsigned offset)
+{
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+	int ret;
+
+	if(readl(netx4000_gc->base + NETX4000_GPIO_OE) & (1 << offset))
+		ret = readl(netx4000_gc->base + NETX4000_GPIO_OUT) & (1 << offset);
+	else
+		ret = readl(netx4000_gc->base + NETX4000_GPIO_IN) & (1 << offset);
+
+	return ret;
+}
+
+static int netx4000_gpio_get_multiple(struct gpio_chip *gc, unsigned long *mask,
+				  unsigned long *bits)
+{
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+	uint32_t oe = readl(netx4000_gc->base + NETX4000_GPIO_OE);
+
+	uint32_t in_vals = (readl(netx4000_gc->base + NETX4000_GPIO_IN) & (~oe)) | 
+	                   (readl(netx4000_gc->base + NETX4000_GPIO_OUT) & oe);
+
+	bits[0] = in_vals & mask[0];
+
+	return 0;
+}
+
+static void netx4000_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+
+	if(value)
+		writel(1 << offset, netx4000_gc->base + NETX4000_GPIO_OUT_SET);
+	else
+		writel(1 << offset, netx4000_gc->base + NETX4000_GPIO_OUT_CLR);
+}
+
+static void netx4000_gpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,
+				   unsigned long *bits)
+{
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+
+	writel(bits[0] & mask[0], netx4000_gc->base + NETX4000_GPIO_OUT_SET);
+}
+
+static int netx4000_gpio_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+
+	writel(1 << offset, netx4000_gc->base + NETX4000_GPIO_OE_CLR);
+
+	return 0;
+}
+
+static int netx4000_gpio_direction_output(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+
+	netx4000_gpio_set(gc, offset, value);
+	writel(1 << offset, netx4000_gc->base + NETX4000_GPIO_OE_SET);
+
+	return 0;
+}
+
+static int netx4000_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
+{
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+
+	if(readl(netx4000_gc->base + NETX4000_GPIO_OE) & (1 << offset))
+		return GPIO_LINE_DIRECTION_OUT;
+	else
+		return GPIO_LINE_DIRECTION_IN;
+}
+
+static int netx4000_gpio_probe(struct platform_device *pdev)
+{
+	const char *name = dev_name(&pdev->dev);
+	struct device_node *node = pdev->dev.of_node;
+	int ret;
+	struct netx4000_gpio_chip *netx4000_gc;
+
+	netx4000_gc = devm_kzalloc(&pdev->dev, sizeof(*netx4000_gc), GFP_KERNEL);
+	if (!netx4000_gc)
+		return -ENOMEM;
+
+	spin_lock_init(&netx4000_gc->gpio_lock);
+
+	netx4000_gc->chip.ngpio = NETX4000_GPIO_MAX_NGPIO;
+	netx4000_gc->chip.direction_input = netx4000_gpio_direction_input;
+	netx4000_gc->chip.direction_output = netx4000_gpio_direction_output;
+	netx4000_gc->chip.get_direction = netx4000_gpio_get_direction;
+	netx4000_gc->chip.get = netx4000_gpio_get;
+	netx4000_gc->chip.get_multiple = netx4000_gpio_get_multiple;
+	netx4000_gc->chip.set = netx4000_gpio_set;
+	netx4000_gc->chip.set_multiple = netx4000_gpio_set_multiple;
+	netx4000_gc->chip.owner = THIS_MODULE;
+	netx4000_gc->chip.parent = &pdev->dev;
+	netx4000_gc->chip.label = name;
+	netx4000_gc->chip.base = -1;
+
+	if (of_property_read_bool(node, "gpio-ranges")) {
+		netx4000_gc->chip.request = gpiochip_generic_request;
+		netx4000_gc->chip.free = gpiochip_generic_free;
+	}
+
+	platform_set_drvdata(pdev, netx4000_gc);
+
+	netx4000_gc->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(netx4000_gc->base)) {
+		ret = PTR_ERR(netx4000_gc->base);
+		dev_err(&pdev->dev, "Error mapping memory (ret=%d)!\n", ret);
+		return ret;
+	}
+
+	netx4000_gc->irq = platform_get_irq(pdev, 0);
+	if (netx4000_gc->irq > 0) {
+		struct gpio_irq_chip* girq = &netx4000_gc->chip.irq;
+
+		gpio_irq_chip_set_chip(girq, &netx4000_gpio_irq_chip);
+		girq->default_type = IRQ_TYPE_NONE;
+		girq->num_parents = 1;
+		girq->parents = &netx4000_gc->irq;
+		girq->parent_handler = netx4000_gpio_irq_handler;
+		girq->parent_handler_data = netx4000_gc;
+	}
+
+	ret = gpiochip_add_data(&netx4000_gc->chip, netx4000_gc);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed adding memory mapped gpiochip\n");
+		return ret;
+	}
+
+	dev_info(&pdev->dev, "successfully initialized!\n");
+
+	return 0;
+}
+
+static int netx4000_gpio_remove(struct platform_device *pdev)
+{
+	struct netx4000_gpio_chip *netx4000_gc = platform_get_drvdata(pdev);
+
+	gpiochip_remove(&netx4000_gc->chip);
+
+	dev_info(&pdev->dev, "successfully removed!\n");
+
+	return -EIO;
+}
+
+static const struct of_device_id netx4000_gpio_of_match[] = {
+	{ .compatible = "hilscher,netx4000-gpio", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, netx4000_gpio_of_match);
+
+static struct platform_driver netx4000_gpio_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = of_match_ptr(netx4000_gpio_of_match),
+	},
+	.probe		= netx4000_gpio_probe,
+	.remove		= netx4000_gpio_remove,
+};
+
+static int __init netx4000_gpio_init(void)
+{
+	pr_info("%s: %s\n", DRIVER_NAME, DRIVER_DESC);
+	return platform_driver_register(&netx4000_gpio_driver);
+}
+subsys_initcall(netx4000_gpio_init);
+
+static void __exit netx4000_gpio_exit(void)
+{
+	platform_driver_unregister(&netx4000_gpio_driver);
+}
+module_exit(netx4000_gpio_exit);
+
+MODULE_AUTHOR("Hilscher Gesellschaft fuer Systemautomation mbH");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL v2");
+
-- 
2.25.1

