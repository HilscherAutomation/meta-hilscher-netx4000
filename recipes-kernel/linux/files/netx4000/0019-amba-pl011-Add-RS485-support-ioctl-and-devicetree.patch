From c6665357dba2fb65d554ad1061064a84a6deb90d Mon Sep 17 00:00:00 2001
From: Michael Trensch <mtrensch@hilscher.com>
Date: Mon, 10 May 2021 10:10:59 +0200
Subject: [PATCH 19/20] amba-pl011: Add RS485 support (ioctl and devicetree).

This patch is based on https://patchwork.kernel.org/patch/9874525.
---
 drivers/tty/serial/amba-pl011.c | 105 ++++++++++++++++++++++++++++++++
 1 file changed, 105 insertions(+)
 mode change 100644 => 100755 drivers/tty/serial/amba-pl011.c

diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
old mode 100644
new mode 100755
index 87dc3fc15694..f9cf856384ff
--- a/drivers/tty/serial/amba-pl011.c
+++ b/drivers/tty/serial/amba-pl011.c
@@ -41,6 +41,7 @@
 #include <linux/sizes.h>
 #include <linux/io.h>
 #include <linux/acpi.h>
+#include <linux/of_gpio.h>
 
 #include "amba-pl011.h"
 
@@ -273,6 +274,9 @@ struct uart_amba_port {
 	struct pl011_dmatx_data	dmatx;
 	bool			dma_probed;
 #endif
+	int rs485_txen_gpio;
+	enum of_gpio_flags rs485_txen_gpio_flags;
+	char rs485_txen_gpio_name[32];
 };
 
 static unsigned int pl011_reg_to_offset(const struct uart_amba_port *uap,
@@ -1286,12 +1290,35 @@ static inline bool pl011_dma_rx_running(struct uart_amba_port *uap)
 
 static void pl011_stop_tx(struct uart_port *port)
 {
+	unsigned int cr;
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
 
 	uap->im &= ~UART011_TXIM;
 	pl011_write(uap->im, uap, REG_IMSC);
 	pl011_dma_tx_stop(uap);
+
+	/* Handle RS-485 */
+	if (port->rs485.flags & SER_RS485_ENABLED) {
+		while (readl(port->membase + UART01x_FR) & UART01x_FR_BUSY)
+			udelay(10);
+		if (port->rs485.delay_rts_after_send)
+			mdelay(port->rs485.delay_rts_after_send);
+		if (uap->rs485_txen_gpio > 0) {
+			if (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
+				gpio_set_value(uap->rs485_txen_gpio, (uap->rs485_txen_gpio_flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1);
+			else
+				gpio_set_value(uap->rs485_txen_gpio, (uap->rs485_txen_gpio_flags & OF_GPIO_ACTIVE_LOW) ? 1 : 0);
+		}
+		else {
+			cr = readw(uap->port.membase + UART011_CR);
+			if (port->rs485.flags & SER_RS485_RTS_AFTER_SEND)
+				cr &= ~UART011_CR_RTS;
+			else
+				cr |= UART011_CR_RTS;
+			writew(cr, uap->port.membase + UART011_CR);
+		}
+	}
 }
 
 static bool pl011_tx_chars(struct uart_amba_port *uap, bool from_irq);
@@ -1307,9 +1334,30 @@ static void pl011_start_tx_pio(struct uart_amba_port *uap)
 
 static void pl011_start_tx(struct uart_port *port)
 {
+	unsigned int cr;
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
 
+	/* Handle RS-485 */
+	if (port->rs485.flags & SER_RS485_ENABLED) {
+		if (uap->rs485_txen_gpio > 0) {
+			if (port->rs485.flags & SER_RS485_RTS_ON_SEND)
+				gpio_set_value(uap->rs485_txen_gpio, (uap->rs485_txen_gpio_flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1);
+			else
+				gpio_set_value(uap->rs485_txen_gpio, (uap->rs485_txen_gpio_flags & OF_GPIO_ACTIVE_LOW) ? 1 : 0);
+		}
+		else {
+			cr = readw(uap->port.membase + UART011_CR);
+			if (port->rs485.flags & SER_RS485_RTS_ON_SEND)
+				cr |= UART011_CR_RTS;
+			else
+				cr &= ~UART011_CR_RTS;
+			writew(cr, uap->port.membase + UART011_CR);
+		}
+		if (port->rs485.delay_rts_before_send)
+			mdelay(port->rs485.delay_rts_before_send);
+	}
+
 	if (!pl011_dma_tx_start(uap))
 		pl011_start_tx_pio(uap);
 }
@@ -2590,6 +2638,42 @@ static int pl011_find_free_port(void)
 	return -EBUSY;
 }
 
+/* IOCTL support for RS485 */
+static int pl011_rs485_config(struct uart_port *port, struct serial_rs485 *rs485conf)
+{
+	if (rs485conf->flags & SER_RS485_RX_DURING_TX) {
+		dev_warn(port->dev, "Ignore unsupported flag SER_RS485_RX_DURING_TX\n");
+		rs485conf->flags &= ~SER_RS485_RX_DURING_TX;
+	}
+	if (rs485conf->flags & SER_RS485_TERMINATE_BUS) {
+		dev_warn(port->dev, "Ignore unsupported flag SER_RS485_TERMINATE_BUS\n");
+		rs485conf->flags &= ~SER_RS485_TERMINATE_BUS;
+	}
+	if (rs485conf->delay_rts_before_send > 99) {
+		dev_warn(port->dev, "Limit delay_rts_before_send to 99ms\n");
+		rs485conf->delay_rts_before_send = 99;
+	}
+	if (rs485conf->delay_rts_after_send > 99) {
+		dev_warn(port->dev, "Limit delay_rts_after_send to 99ms\n");
+		rs485conf->delay_rts_after_send = 99;
+	}
+
+	if (memcmp(&port->rs485, rs485conf, sizeof(port->rs485))) {
+		port->rs485 = *rs485conf;
+		dev_dbg(port->dev, "%cSER_RS485_ENABLED, %cSER_RS485_RTS_ON_SEND, %cSER_RS485_RTS_AFTER_SEND, %cSER_RS485_RX_DURING_TX, %cSER_RS485_TERMINATE_BUS, delay_rts_before_send %ums, delay_rts_after_send %ums",
+			(port->rs485.flags & SER_RS485_ENABLED) ? '+' : '-',
+			(port->rs485.flags & SER_RS485_RTS_ON_SEND) ? '+' : '-',
+			(port->rs485.flags & SER_RS485_RTS_AFTER_SEND) ? '+' : '-',
+			(port->rs485.flags & SER_RS485_RX_DURING_TX) ? '+' : '-',
+			(port->rs485.flags & SER_RS485_TERMINATE_BUS) ? '+' : '-',
+			port->rs485.delay_rts_before_send,
+			port->rs485.delay_rts_before_send
+		);
+	}
+
+	return 0;
+}
+
 static int pl011_setup_port(struct device *dev, struct uart_amba_port *uap,
 			    struct resource *mmiobase, int index)
 {
@@ -2601,6 +2685,24 @@ static int pl011_setup_port(struct device *dev, struct uart_amba_port *uap,
 
 	index = pl011_probe_dt_alias(index, dev);
 
+	uap->rs485_txen_gpio = of_get_named_gpio_flags(dev->of_node, "rs485-txen-gpio", 0, &uap->rs485_txen_gpio_flags);
+
+	if(uap->rs485_txen_gpio == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
+	if (uap->rs485_txen_gpio > 0) {
+		snprintf(uap->rs485_txen_gpio_name, sizeof(uap->rs485_txen_gpio_name), "pl011-rs485-txen%d", index);
+		if (!gpio_is_valid(uap->rs485_txen_gpio)) {
+			dev_err(dev, "Invalid GPIO rs485-txen-gpio (%d).\n", uap->rs485_txen_gpio);
+			return -EINVAL;
+		}
+		if (devm_gpio_request_one(dev, uap->rs485_txen_gpio, (uap->rs485_txen_gpio_flags & OF_GPIO_ACTIVE_LOW) ? (GPIOF_ACTIVE_LOW | GPIOF_OUT_INIT_HIGH) : GPIOF_OUT_INIT_LOW, uap->rs485_txen_gpio_name) < 0) {
+			dev_err(dev, "Error requesting GPIO rs485-txen-gpio (%d).\n", uap->rs485_txen_gpio);
+			return -EINVAL;
+		}
+		dev_info(dev, "gpio%d used as tx-enable for RS485 mode (active-%s)\n", uap->rs485_txen_gpio, (uap->rs485_txen_gpio_flags & OF_GPIO_ACTIVE_LOW) ? "low" : "high");
+	}
+
 	uap->old_cr = 0;
 	uap->port.dev = dev;
 	uap->port.mapbase = mmiobase->start;
@@ -2610,6 +2712,9 @@ static int pl011_setup_port(struct device *dev, struct uart_amba_port *uap,
 	uap->port.flags = UPF_BOOT_AUTOCONF;
 	uap->port.line = index;
 
+	uart_get_rs485_mode(&uap->port);
+	uap->port.rs485_config = pl011_rs485_config;
+
 	amba_ports[index] = uap;
 
 	return 0;
-- 
2.17.1

