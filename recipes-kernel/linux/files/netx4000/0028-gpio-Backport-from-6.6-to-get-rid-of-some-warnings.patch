From 3c38151255b39fe109df6157ee18b9b8a411c38f Mon Sep 17 00:00:00 2001
From: Michael Trensch <mtrensch@hilscher.com>
Date: Thu, 1 Feb 2024 12:58:24 +0100
Subject: [PATCH] gpio: Backport from 6.6 to get rid of some warnings:

Upstream-Status: Pending

See following warnings:
  gpio gpiochip0: (/amba/gpio@f801f000): not an immutable chip, please consider fixing it!
---
 drivers/gpio/gpio-netx4000.c | 179 ++++++++++++++++++++---------------
 1 file changed, 104 insertions(+), 75 deletions(-)

diff --git a/drivers/gpio/gpio-netx4000.c b/drivers/gpio/gpio-netx4000.c
index 1bd3886dbea3..1e1f67c08a63 100644
--- a/drivers/gpio/gpio-netx4000.c
+++ b/drivers/gpio/gpio-netx4000.c
@@ -40,8 +40,8 @@
 #define NETX4000_GPIO_OE_CLR	(0x34)
 
 struct netx4000_gpio_chip {
-	struct of_mm_gpio_chip chip;
-	struct irq_chip irq_chip;
+	struct gpio_chip chip;
+	void __iomem *base;
 
 	/* irq handling stuff */
 	spinlock_t gpio_lock;
@@ -51,48 +51,40 @@ struct netx4000_gpio_chip {
 	u32 irq_enabled;
 };
 
-static struct netx4000_gpio_chip *to_netx4000_gc(struct gpio_chip *gc)
-{
-	return container_of(gc, struct netx4000_gpio_chip, chip.gc);
-}
-
 static void netx4000_gpio_irq_handler(struct irq_desc *desc)
 {
-	struct netx4000_gpio_chip *netx4000_gc;
+    struct gpio_chip *gc = irq_desc_get_handler_data(desc);
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
 	int i;
-	struct irq_domain *irqdomain;
-	struct irq_chip *chip;
 	unsigned long status;
 
-	netx4000_gc = to_netx4000_gc(irq_desc_get_handler_data(desc));
-	chip = irq_desc_get_chip(desc);
-	irqdomain = netx4000_gc->chip.gc.irq.domain;
-
 	chained_irq_enter(chip, desc);
 
-	status = readl(netx4000_gc->chip.regs + NETX4000_GPIO_IRQ_SRC);
-	writel(status, netx4000_gc->chip.regs + NETX4000_GPIO_IRQ_SRC);
+	status = readl(netx4000_gc->base + NETX4000_GPIO_IRQ_SRC);
+	writel(status, netx4000_gc->base + NETX4000_GPIO_IRQ_SRC);
 
-	for_each_set_bit(i, &status, netx4000_gc->chip.gc.ngpio)
-		generic_handle_irq(irq_find_mapping(irqdomain, i));
+	for_each_set_bit(i, &status, netx4000_gc->chip.ngpio)
+		generic_handle_domain_irq(gc->irq.domain,
+                                  i);
 
 	chained_irq_exit(chip, desc);
 }
 
 static void netx4000_gpio_irq_unmask(struct irq_data *d)
 {
-	struct netx4000_gpio_chip *netx4000_gc;
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
 	unsigned offset;
 	unsigned long flags;
 
-	netx4000_gc = to_netx4000_gc(irq_data_get_irq_chip_data(d));
 	offset = d->hwirq;
 
 	spin_lock_irqsave(&netx4000_gc->gpio_lock, flags);
 	writel(netx4000_gc->posedge_enable,
-		netx4000_gc->chip.regs + NETX4000_GPIO_IRQ_PEDGE);
+		netx4000_gc->base + NETX4000_GPIO_IRQ_PEDGE);
 	writel(netx4000_gc->negedge_enable,
-		netx4000_gc->chip.regs + NETX4000_GPIO_IRQ_NEDGE);
+		netx4000_gc->base + NETX4000_GPIO_IRQ_NEDGE);
 
 	netx4000_gc->irq_enabled |= (1 << offset);
 	spin_unlock_irqrestore(&netx4000_gc->gpio_lock, flags);
@@ -100,18 +92,18 @@ static void netx4000_gpio_irq_unmask(struct irq_data *d)
 
 static void netx4000_gpio_irq_mask(struct irq_data *d)
 {
-	struct netx4000_gpio_chip *netx4000_gc;
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
 	unsigned offset;
 	unsigned long flags;
 
-	netx4000_gc = to_netx4000_gc(irq_data_get_irq_chip_data(d));
 	offset = d->hwirq;
 
 	spin_lock_irqsave(&netx4000_gc->gpio_lock, flags);
 	writel(netx4000_gc->posedge_enable & ~(1 << offset),
-		netx4000_gc->chip.regs + NETX4000_GPIO_IRQ_PEDGE);
+		netx4000_gc->base + NETX4000_GPIO_IRQ_PEDGE);
 	writel(netx4000_gc->negedge_enable & ~(1 << offset),
-		netx4000_gc->chip.regs + NETX4000_GPIO_IRQ_NEDGE);
+		netx4000_gc->base + NETX4000_GPIO_IRQ_NEDGE);
 
 	netx4000_gc->irq_enabled &= ~(1 << offset);
 	spin_unlock_irqrestore(&netx4000_gc->gpio_lock, flags);
@@ -119,12 +111,12 @@ static void netx4000_gpio_irq_mask(struct irq_data *d)
 
 static int netx4000_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 {
-	struct netx4000_gpio_chip *netx4000_gc;
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
 	unsigned offset;
 	unsigned long flags;
 	int ret = 0;
 
-	netx4000_gc = to_netx4000_gc(irq_data_get_irq_chip_data(d));
 	offset = d->hwirq;
 
 	spin_lock_irqsave(&netx4000_gc->gpio_lock, flags);
@@ -150,6 +142,7 @@ static int netx4000_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 		break;
 
 	case IRQ_TYPE_LEVEL_HIGH:
+	case IRQ_TYPE_LEVEL_LOW:
 	default:
 		ret = -EINVAL;
 		break;
@@ -160,58 +153,93 @@ static int netx4000_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 	return ret;
 }
 
+static const struct irq_chip netx4000_gpio_irq_chip = {
+	.name           = "gpio-netx34000",
+	.irq_mask       = netx4000_gpio_irq_mask,
+	.irq_unmask     = netx4000_gpio_irq_unmask,
+	.irq_set_type   = netx4000_gpio_irq_set_type,
+	.flags          = IRQCHIP_IMMUTABLE | IRQCHIP_SET_TYPE_MASKED |
+			  IRQCHIP_MASK_ON_SUSPEND,
+	GPIOCHIP_IRQ_RESOURCE_HELPERS,
+};
+
 static int netx4000_gpio_get(struct gpio_chip *gc, unsigned offset)
 {
-	struct of_mm_gpio_chip *mm_gc;
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
 	int ret;
 
-	mm_gc = to_of_mm_gpio_chip(gc);
-
-	if(readl(mm_gc->regs + NETX4000_GPIO_OE) & (1 << offset))
-		ret = readl(mm_gc->regs + NETX4000_GPIO_OUT) & (1 << offset);
+	if(readl(netx4000_gc->base + NETX4000_GPIO_OE) & (1 << offset))
+		ret = readl(netx4000_gc->base + NETX4000_GPIO_OUT) & (1 << offset);
 	else
-		ret = readl(mm_gc->regs + NETX4000_GPIO_IN) & (1 << offset);
+		ret = readl(netx4000_gc->base + NETX4000_GPIO_IN) & (1 << offset);
 
 	return ret;
 }
 
-static void netx4000_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
+static int netx4000_gpio_get_multiple(struct gpio_chip *gc, unsigned long *mask,
+				  unsigned long *bits)
 {
-	struct of_mm_gpio_chip *mm_gc;
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+	uint32_t oe = readl(netx4000_gc->base + NETX4000_GPIO_OE);
+
+	uint32_t in_vals = (readl(netx4000_gc->base + NETX4000_GPIO_IN) & (~oe)) | 
+	                   (readl(netx4000_gc->base + NETX4000_GPIO_OUT) & oe);
+
+	bits[0] = in_vals & mask[0];
+
+	return 0;
+}
 
-	mm_gc = to_of_mm_gpio_chip(gc);
+static void netx4000_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
 
 	if(value)
-		writel(1 << offset, mm_gc->regs + NETX4000_GPIO_OUT_SET);
+		writel(1 << offset, netx4000_gc->base + NETX4000_GPIO_OUT_SET);
 	else
-		writel(1 << offset, mm_gc->regs + NETX4000_GPIO_OUT_CLR);
+		writel(1 << offset, netx4000_gc->base + NETX4000_GPIO_OUT_CLR);
 }
 
-static int netx4000_gpio_direction_input(struct gpio_chip *gc, unsigned offset)
+static void netx4000_gpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,
+				   unsigned long *bits)
 {
-	struct of_mm_gpio_chip *mm_gc;
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
 
-	mm_gc = to_of_mm_gpio_chip(gc);
+	writel(bits[0] & mask[0], netx4000_gc->base + NETX4000_GPIO_OUT_SET);
+}
 
-	writel(1 << offset, mm_gc->regs + NETX4000_GPIO_OE_CLR);
+static int netx4000_gpio_direction_input(struct gpio_chip *gc, unsigned offset)
+{
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+
+	writel(1 << offset, netx4000_gc->base + NETX4000_GPIO_OE_CLR);
 
 	return 0;
 }
 
 static int netx4000_gpio_direction_output(struct gpio_chip *gc, unsigned offset, int value)
 {
-	struct of_mm_gpio_chip *mm_gc;
-
-	mm_gc = to_of_mm_gpio_chip(gc);
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
 
 	netx4000_gpio_set(gc, offset, value);
-	writel(1 << offset, mm_gc->regs + NETX4000_GPIO_OE_SET);
+	writel(1 << offset, netx4000_gc->base + NETX4000_GPIO_OE_SET);
 
 	return 0;
 }
 
+static int netx4000_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
+{
+	struct netx4000_gpio_chip *netx4000_gc = gpiochip_get_data(gc);
+
+	if(readl(netx4000_gc->base + NETX4000_GPIO_OE) & (1 << offset))
+		return GPIO_LINE_DIRECTION_OUT;
+	else
+		return GPIO_LINE_DIRECTION_IN;
+}
+
 static int netx4000_gpio_probe(struct platform_device *pdev)
 {
+	const char *name = dev_name(&pdev->dev);
 	struct device_node *node = pdev->dev.of_node;
 	int ret;
 	struct netx4000_gpio_chip *netx4000_gc;
@@ -222,45 +250,46 @@ static int netx4000_gpio_probe(struct platform_device *pdev)
 
 	spin_lock_init(&netx4000_gc->gpio_lock);
 
-	netx4000_gc->chip.gc.ngpio 		= NETX4000_GPIO_MAX_NGPIO;
-	netx4000_gc->chip.gc.direction_input	= netx4000_gpio_direction_input;
-	netx4000_gc->chip.gc.direction_output	= netx4000_gpio_direction_output;
-	netx4000_gc->chip.gc.get		= netx4000_gpio_get;
-	netx4000_gc->chip.gc.set		= netx4000_gpio_set;
-	netx4000_gc->chip.gc.owner		= THIS_MODULE;
-	netx4000_gc->chip.gc.parent		= &pdev->dev;
+	netx4000_gc->chip.ngpio = NETX4000_GPIO_MAX_NGPIO;
+	netx4000_gc->chip.direction_input = netx4000_gpio_direction_input;
+	netx4000_gc->chip.direction_output = netx4000_gpio_direction_output;
+	netx4000_gc->chip.get_direction = netx4000_gpio_get_direction;
+	netx4000_gc->chip.get = netx4000_gpio_get;
+	netx4000_gc->chip.get_multiple = netx4000_gpio_get_multiple;
+	netx4000_gc->chip.set = netx4000_gpio_set;
+	netx4000_gc->chip.set_multiple = netx4000_gpio_set_multiple;
+	netx4000_gc->chip.owner = THIS_MODULE;
+	netx4000_gc->chip.parent = &pdev->dev;
+	netx4000_gc->chip.label = name;
+	netx4000_gc->chip.base = -1;
 
 	if (of_property_read_bool(node, "gpio-ranges")) {
-		netx4000_gc->chip.gc.request = gpiochip_generic_request;
-		netx4000_gc->chip.gc.free = gpiochip_generic_free;
+		netx4000_gc->chip.request = gpiochip_generic_request;
+		netx4000_gc->chip.free = gpiochip_generic_free;
 	}
 
 	platform_set_drvdata(pdev, netx4000_gc);
 
+	netx4000_gc->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(netx4000_gc->base)) {
+		ret = PTR_ERR(netx4000_gc->base);
+		dev_err(&pdev->dev, "Error mapping memory (ret=%d)!\n", ret);
+		return ret;
+	}
+
 	netx4000_gc->irq = platform_get_irq(pdev, 0);
 	if (netx4000_gc->irq > 0) {
-		struct irq_chip* irqc = &netx4000_gc->irq_chip;
-		struct gpio_irq_chip* girq = &netx4000_gc->chip.gc.irq;
-
-		irqc->name         = dev_name(&pdev->dev);
-		irqc->irq_mask     = netx4000_gpio_irq_mask;
-		irqc->irq_unmask   = netx4000_gpio_irq_unmask;
-		irqc->irq_set_type = netx4000_gpio_irq_set_type;
-
-		girq->chip = irqc;
-		girq->parent_handler = netx4000_gpio_irq_handler;
-		girq->num_parents = 1;
-		girq->parents = devm_kcalloc(&pdev->dev, 1, sizeof(*girq->parents),
-					    GFP_KERNEL);
-		if (!girq->parents)
-			return -ENOMEM;
+		struct gpio_irq_chip* girq = &netx4000_gc->chip.irq;
 
+		gpio_irq_chip_set_chip(girq, &netx4000_gpio_irq_chip);
 		girq->default_type = IRQ_TYPE_NONE;
-		girq->handler = handle_simple_irq;
-		girq->parents[0] = netx4000_gc->irq;
+		girq->num_parents = 1;
+		girq->parents = &netx4000_gc->irq;
+		girq->parent_handler = netx4000_gpio_irq_handler;
+		girq->parent_handler_data = netx4000_gc;
 	}
 
-	ret = of_mm_gpiochip_add(node, &netx4000_gc->chip);
+	ret = gpiochip_add_data(&netx4000_gc->chip, netx4000_gc);
 	if (ret) {
 		dev_err(&pdev->dev, "Failed adding memory mapped gpiochip\n");
 		return ret;
@@ -275,7 +304,7 @@ static int netx4000_gpio_remove(struct platform_device *pdev)
 {
 	struct netx4000_gpio_chip *netx4000_gc = platform_get_drvdata(pdev);
 
-	of_mm_gpiochip_remove(&netx4000_gc->chip);
+	gpiochip_remove(&netx4000_gc->chip);
 
 	dev_info(&pdev->dev, "successfully removed!\n");
 
-- 
2.25.1

