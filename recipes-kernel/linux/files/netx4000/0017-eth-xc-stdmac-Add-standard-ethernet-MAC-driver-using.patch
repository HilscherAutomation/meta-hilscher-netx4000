From 477548ea2b8a73b0c9a6e90c91994e5242891134 Mon Sep 17 00:00:00 2001
From: Michael Trensch <mtrensch@hilscher.com>
Date: Mon, 10 May 2021 10:09:35 +0200
Subject: [PATCH 17/20] eth,xc-stdmac: Add standard ethernet MAC driver using
 XC.

ATTENTION: This driver must no be used, if a communication firmware (e.g. PROFINET)
is running on R7 side. It also requires firewalls between A9/R7 side to be open.
---
 .../arm/boot/dts/netx4000/overlays/xceth0.dts |  11 +
 .../arm/boot/dts/netx4000/overlays/xceth1.dts |  11 +
 drivers/net/ethernet/Kconfig                  |   1 +
 drivers/net/ethernet/Makefile                 |   1 +
 drivers/net/ethernet/netx4000/Kconfig         |  11 +
 drivers/net/ethernet/netx4000/Makefile        |   3 +
 .../ethernet/netx4000/ethmac_xpec_regdef.h    | 926 ++++++++++++++++++
 .../net/ethernet/netx4000/mdio-xc-netx4000.c  | 392 ++++++++
 drivers/net/ethernet/netx4000/netx4000-eth.c  | 590 +++++++++++
 .../net/ethernet/netx4000/netx4000-xc-hal.c   | 909 +++++++++++++++++
 .../net/ethernet/netx4000/netx4000-xc-hal.h   |  78 ++
 .../net/ethernet/netx4000/netx4000-xc-res.h   | 811 +++++++++++++++
 drivers/net/ethernet/netx4000/netx4000-xc.c   | 476 +++++++++
 drivers/net/ethernet/netx4000/netx4000-xc.h   |  38 +
 .../ethernet/netx4000/netx4000-xceth-hal.c    | 914 +++++++++++++++++
 .../ethernet/netx4000/netx4000-xceth-hal.h    |  74 ++
 16 files changed, 5246 insertions(+)
 create mode 100644 arch/arm/boot/dts/netx4000/overlays/xceth0.dts
 create mode 100644 arch/arm/boot/dts/netx4000/overlays/xceth1.dts
 create mode 100644 drivers/net/ethernet/netx4000/Kconfig
 create mode 100644 drivers/net/ethernet/netx4000/Makefile
 create mode 100644 drivers/net/ethernet/netx4000/ethmac_xpec_regdef.h
 create mode 100644 drivers/net/ethernet/netx4000/mdio-xc-netx4000.c
 create mode 100644 drivers/net/ethernet/netx4000/netx4000-eth.c
 create mode 100644 drivers/net/ethernet/netx4000/netx4000-xc-hal.c
 create mode 100644 drivers/net/ethernet/netx4000/netx4000-xc-hal.h
 create mode 100644 drivers/net/ethernet/netx4000/netx4000-xc-res.h
 create mode 100644 drivers/net/ethernet/netx4000/netx4000-xc.c
 create mode 100644 drivers/net/ethernet/netx4000/netx4000-xc.h
 create mode 100644 drivers/net/ethernet/netx4000/netx4000-xceth-hal.c
 create mode 100644 drivers/net/ethernet/netx4000/netx4000-xceth-hal.h

diff --git a/arch/arm/boot/dts/netx4000/overlays/xceth0.dts b/arch/arm/boot/dts/netx4000/overlays/xceth0.dts
new file mode 100644
index 000000000000..3a93e8e59e27
--- /dev/null
+++ b/arch/arm/boot/dts/netx4000/overlays/xceth0.dts
@@ -0,0 +1,11 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&xceth0>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/netx4000/overlays/xceth1.dts b/arch/arm/boot/dts/netx4000/overlays/xceth1.dts
new file mode 100644
index 000000000000..8e91355df437
--- /dev/null
+++ b/arch/arm/boot/dts/netx4000/overlays/xceth1.dts
@@ -0,0 +1,11 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&xceth1>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index 1cdff1dca790..0d7895b4bee9 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -43,6 +43,7 @@ source "drivers/net/ethernet/chelsio/Kconfig"
 source "drivers/net/ethernet/cirrus/Kconfig"
 source "drivers/net/ethernet/cisco/Kconfig"
 source "drivers/net/ethernet/cortina/Kconfig"
+source "drivers/net/ethernet/netx4000/Kconfig"
 
 config CX_ECAT
 	tristate "Beckhoff CX5020 EtherCAT master support"
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index cb3f9084a21b..a00d159a18ac 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -64,6 +64,7 @@ obj-$(CONFIG_NET_VENDOR_NATSEMI) += natsemi/
 obj-$(CONFIG_NET_VENDOR_NETERION) += neterion/
 obj-$(CONFIG_NET_VENDOR_NETRONOME) += netronome/
 obj-$(CONFIG_NET_VENDOR_NI) += ni/
+obj-$(CONFIG_ARCH_NETX4000) += netx4000/
 obj-$(CONFIG_NET_VENDOR_NVIDIA) += nvidia/
 obj-$(CONFIG_LPC_ENET) += nxp/
 obj-$(CONFIG_NET_VENDOR_OKI) += oki-semi/
diff --git a/drivers/net/ethernet/netx4000/Kconfig b/drivers/net/ethernet/netx4000/Kconfig
new file mode 100644
index 000000000000..5d00be72bb2b
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/Kconfig
@@ -0,0 +1,11 @@
+#
+# netX4000 network device configuration
+#
+
+config NETX4000_XC_STDMAC
+	tristate "Hilscher netX4000 XC Standard ethernet MAC (10/100MBit)"
+	depends on ARCH_NETX4000
+	select FIRMWARE_LOADER
+	help
+	  This driver supports netX4000 based XC standard MAC devices.
+	  Requires a binary firmware supplied via firmware loader
diff --git a/drivers/net/ethernet/netx4000/Makefile b/drivers/net/ethernet/netx4000/Makefile
new file mode 100644
index 000000000000..92f5a2784ee5
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_NETX4000_XC_STDMAC) += mdio-xc-netx4000.o netx4000-xc-stdmac.o
+
+netx4000-xc-stdmac-y := netx4000-eth.o netx4000-xceth-hal.o netx4000-xc.o netx4000-xc-hal.o
diff --git a/drivers/net/ethernet/netx4000/ethmac_xpec_regdef.h b/drivers/net/ethernet/netx4000/ethmac_xpec_regdef.h
new file mode 100644
index 000000000000..4278b1b172ef
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/ethmac_xpec_regdef.h
@@ -0,0 +1,926 @@
+#ifndef ethmac_xpec_regdef_h__
+#define ethmac_xpec_regdef_h__
+
+//#include <stdint.h>
+
+/* ===================================================================== */
+/* Area ETHMAC_TXAREABASE */
+/* ===================================================================== */
+
+#define REL_Adr_AREA_ETHMAC_TXAREABASE  0x00000000U
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_TX_RETRY */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_TX_RETRY  0x00000000U
+
+/* retry counter for transmission attempts */
+#define MSK_ETHMAC_TX_RETRY_CNT  0xffffffffU
+#define SRT_ETHMAC_TX_RETRY_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_TX_TIMESTAMP_NS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_TX_TIMESTAMP_NS  0x00000004U
+
+/* transmit timestamp ns of outgoing packet */
+#define MSK_ETHMAC_TX_TIMESTAMP_NS_VAL  0xffffffffU
+#define SRT_ETHMAC_TX_TIMESTAMP_NS_VAL            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_TX_TIMESTAMP_S */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_TX_TIMESTAMP_S  0x00000008U
+
+/* transmit timestamp s of outgoing packet */
+#define MSK_ETHMAC_TX_TIMESTAMP_S_VAL  0xffffffffU
+#define SRT_ETHMAC_TX_TIMESTAMP_S_VAL            0
+
+
+/* ===================================================================== */
+/* Area ETHMAC_RXAREABASE */
+/* ===================================================================== */
+
+#define REL_Adr_AREA_ETHMAC_RXAREABASE  0x0000000cU
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_RX_TIMESTAMP_NS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_RX_TIMESTAMP_NS  0x0000000cU
+
+/* receive timestamp ns of incoming packet */
+#define MSK_ETHMAC_RX_TIMESTAMP_NS_VAL  0xffffffffU
+#define SRT_ETHMAC_RX_TIMESTAMP_NS_VAL            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_RX_TIMESTAMP_S */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_RX_TIMESTAMP_S  0x00000010U
+
+/* receive timestamp s of incoming packet */
+#define MSK_ETHMAC_RX_TIMESTAMP_S_VAL  0xffffffffU
+#define SRT_ETHMAC_RX_TIMESTAMP_S_VAL            0
+
+
+/* ===================================================================== */
+/* Area ETHMAC_CONFIG_AREA_BASE */
+/* ===================================================================== */
+
+#define REL_Adr_AREA_ETHMAC_CONFIG_AREA_BASE  0x00000014U
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_MONITORING_MODE */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_MONITORING_MODE  0x00000014U
+
+/* Enable */
+#define MSK_ETHMAC_MONITORING_MODE_VAL  0xffffffffU
+#define SRT_ETHMAC_MONITORING_MODE_VAL            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_TRAFFIC_CLASS_ARRANGEMENT */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_TRAFFIC_CLASS_ARRANGEMENT  0x00000018U
+
+/* Traffic Class arrangement */
+/* 0: HI: vlan priority 7..0, LO: untagged frame */
+/* 1: HI: vlan priority 7..1, LO: vlan priority 0, untagged frame */
+/* 2: HI: vlan priority 7..2, LO: vlan priority 1..0, untagged frame */
+/* 3: HI: vlan priority 7..3, LO: vlan priority 2..0, untagged frame */
+/* 4: HI: vlan priority 7..4, LO: vlan priority 3..0, untagged frame (802.1Q Recommendation) */
+/* 5: HI: vlan priority 7..5, LO: vlan priority 4..0, untagged frame */
+/* 6: HI: vlan priority 7..6, LO: vlan priority 5..0, untagged frame */
+/* 7: HI: vlan priority 7,    LO: vlan priority 6..0, untagged frame */
+/* 8: HI: -,                  LO: vlan priority 7..0, untagged frame */
+#define MSK_ETHMAC_TRAFFIC_CLASS_ARRANGEMENT_VAL  0x0000000fU
+#define SRT_ETHMAC_TRAFFIC_CLASS_ARRANGEMENT_VAL            0
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_TRAFFIC_CLASS_ARRANGEMENT_RES1  0xfffffff0U
+#define SRT_ETHMAC_TRAFFIC_CLASS_ARRANGEMENT_RES1            4
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERRUPTS_ENABLE_IND_HI */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERRUPTS_ENABLE_IND_HI  0x0000001cU
+
+/* enable indication hi event */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_IND_HI_VAL  0x00000001U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_IND_HI_VAL            0
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_IND_HI_RES1  0xfffffffeU
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_IND_HI_RES1            1
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERRUPTS_ENABLE_IND_LO */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERRUPTS_ENABLE_IND_LO  0x00000020U
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_IND_LO_RES1  0x00000001U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_IND_LO_RES1            0
+
+/* enable indication lo event */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_IND_LO_VAL  0x00000002U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_IND_LO_VAL            1
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_IND_LO_RES2  0xfffffffcU
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_IND_LO_RES2            2
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERRUPTS_ENABLE_CON_HI */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERRUPTS_ENABLE_CON_HI  0x00000024U
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_CON_HI_RES1  0x00000003U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_CON_HI_RES1            0
+
+/* enable confirmation hi event */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_CON_HI_VAL  0x00000004U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_CON_HI_VAL            2
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_CON_HI_RES2  0xfffffff8U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_CON_HI_RES2            3
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERRUPTS_ENABLE_CON_LO */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERRUPTS_ENABLE_CON_LO  0x00000028U
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_CON_LO_RES1  0x00000007U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_CON_LO_RES1            0
+
+/* enable confirmation lo event */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_CON_LO_VAL  0x00000008U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_CON_LO_VAL            3
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_CON_LO_RES2  0xfffffff0U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_CON_LO_RES2            4
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED  0x0000002cU
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED_RES1  0x0000000fU
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED_RES1            0
+
+/* enable link status changed event */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED_VAL  0x00000010U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED_VAL            4
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED_RES2  0xffffffe0U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED_RES2            5
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERRUPTS_ENABLE_COL */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERRUPTS_ENABLE_COL  0x00000030U
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_COL_RES1  0x0000001fU
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_COL_RES1            0
+
+/* enable collision event */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_COL_VAL  0x00000020U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_COL_VAL            5
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_COL_RES2  0xffffffc0U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_COL_RES2            6
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERRUPTS_ENABLE_EARLY_RCV */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERRUPTS_ENABLE_EARLY_RCV  0x00000034U
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_EARLY_RCV_RES1  0x0000003fU
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_EARLY_RCV_RES1            0
+
+/* enable event for destination address received and empty_ptr_got and */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_EARLY_RCV_VAL  0x00000040U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_EARLY_RCV_VAL            6
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_EARLY_RCV_RES2  0xffffff80U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_EARLY_RCV_RES2            7
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERRUPTS_ENABLE_RX_ERR */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERRUPTS_ENABLE_RX_ERR  0x00000038U
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_RX_ERR_RES1  0x0000007fU
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_RX_ERR_RES1            0
+
+/* enable event for rx_error event is set in case of all error cases */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_RX_ERR_VAL  0x00000080U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_RX_ERR_VAL            7
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_RX_ERR_RES2  0xffffff00U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_RX_ERR_RES2            8
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERRUPTS_ENABLE_TX_ERR */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERRUPTS_ENABLE_TX_ERR  0x0000003cU
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_TX_ERR_RES1  0x000000ffU
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_TX_ERR_RES1            0
+
+/* enable event for tx_error, event is set in case of late_collision, excessive_collision, utx_under_flow_during_tx, tx_fatal_error */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_TX_ERR_VAL  0x00000100U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_TX_ERR_VAL            8
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_INTERRUPTS_ENABLE_TX_ERR_RES2  0xfffffe00U
+#define SRT_ETHMAC_INTERRUPTS_ENABLE_TX_ERR_RES2            9
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERFACE_MAC_ADDRESS_LO */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERFACE_MAC_ADDRESS_LO  0x00000040U
+
+/* Interface MAC address bytes 4,3,2 and 1 */
+#define MSK_ETHMAC_INTERFACE_MAC_ADDRESS_LO_BYTES_4321  0xffffffffU
+#define SRT_ETHMAC_INTERFACE_MAC_ADDRESS_LO_BYTES_4321            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_INTERFACE_MAC_ADDRESS_HI */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_INTERFACE_MAC_ADDRESS_HI  0x00000044U
+
+/* MAC address bytes 6 and 5 */
+#define MSK_ETHMAC_INTERFACE_MAC_ADDRESS_HI_BYTES_65  0x0000ffffU
+#define SRT_ETHMAC_INTERFACE_MAC_ADDRESS_HI_BYTES_65            0
+
+/* 0x0000 */
+#define MSK_ETHMAC_INTERFACE_MAC_ADDRESS_HI_RES1  0xffff0000U
+#define SRT_ETHMAC_INTERFACE_MAC_ADDRESS_HI_RES1           16
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_2ND_INTERFACE_MAC_ADDRESS_LO */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_2ND_INTERFACE_MAC_ADDRESS_LO  0x00000048U
+
+/* Interface MAC address bytes 4,3,2 and 1 */
+#define MSK_ETHMAC_2ND_INTERFACE_MAC_ADDRESS_LO_BYTES_4321  0xffffffffU
+#define SRT_ETHMAC_2ND_INTERFACE_MAC_ADDRESS_LO_BYTES_4321            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_2ND_INTERFACE_MAC_ADDRESS_HI */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_2ND_INTERFACE_MAC_ADDRESS_HI  0x0000004cU
+
+/* MAC address bytes 6 and 5 */
+#define MSK_ETHMAC_2ND_INTERFACE_MAC_ADDRESS_HI_BYTES_65  0x0000ffffU
+#define SRT_ETHMAC_2ND_INTERFACE_MAC_ADDRESS_HI_BYTES_65            0
+
+/* 0x0000 */
+#define MSK_ETHMAC_2ND_INTERFACE_MAC_ADDRESS_HI_RES1  0xffff0000U
+#define SRT_ETHMAC_2ND_INTERFACE_MAC_ADDRESS_HI_RES1           16
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_SYSTIME_BORDER_COPY_PLUS1 */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_SYSTIME_BORDER_COPY_PLUS1  0x00000050U
+
+/* wrap-around value of systime_ns, systime_s */
+#define MSK_ETHMAC_SYSTIME_BORDER_COPY_PLUS1_VAL  0xffffffffU
+#define SRT_ETHMAC_SYSTIME_BORDER_COPY_PLUS1_VAL            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_TS_COR_BASE_TX */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_TS_COR_BASE_TX  0x00000054U
+
+/* timestamp correction value base for reception in ns */
+#define MSK_ETHMAC_TS_COR_BASE_TX_VAL  0xffffffffU
+#define SRT_ETHMAC_TS_COR_BASE_TX_VAL            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_TS_COR_BASE_RX */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_TS_COR_BASE_RX  0x00000058U
+
+/* timestamp correction value base for transmission in ns */
+#define MSK_ETHMAC_TS_COR_BASE_RX_VAL  0xffffffffU
+#define SRT_ETHMAC_TS_COR_BASE_RX_VAL            0
+
+
+/* ===================================================================== */
+/* Area ETHMAC_STATUS_AREA_BASE */
+/* ===================================================================== */
+
+#define REL_Adr_AREA_ETHMAC_STATUS_AREA_BASE  0x0000005cU
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_OUT_FRAMES_OKAY */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_OUT_FRAMES_OKAY  0x0000005cU
+
+/* count of frames that are transmitted successfully */
+#define MSK_ETHMAC_OUT_FRAMES_OKAY_CNT  0xffffffffU
+#define SRT_ETHMAC_OUT_FRAMES_OKAY_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_OUT_OCTETS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_OUT_OCTETS  0x00000060U
+
+/* count of bytes transmitted */
+#define MSK_ETHMAC_OUT_OCTETS_CNT  0xffffffffU
+#define SRT_ETHMAC_OUT_OCTETS_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_SINGLE_COLLISION_FRAMES */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_SINGLE_COLLISION_FRAMES  0x00000064U
+
+/* count of frames that are involved into a single collision */
+#define MSK_ETHMAC_SINGLE_COLLISION_FRAMES_CNT  0xffffffffU
+#define SRT_ETHMAC_SINGLE_COLLISION_FRAMES_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_MULTIPLE_COLLISION_FRAMES */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_MULTIPLE_COLLISION_FRAMES  0x00000068U
+
+/* count of frames that are involved into more than one collisions */
+#define MSK_ETHMAC_MULTIPLE_COLLISION_FRAMES_CNT  0xffffffffU
+#define SRT_ETHMAC_MULTIPLE_COLLISION_FRAMES_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_LATE_COLLISIONS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_LATE_COLLISIONS  0x0000006cU
+
+/* count of the times that a collision has been detected later than 512 bit times into the transmitted packet */
+#define MSK_ETHMAC_LATE_COLLISIONS_CNT  0xffffffffU
+#define SRT_ETHMAC_LATE_COLLISIONS_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_LINK_DOWN_DURING_TRANSMISSION */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_LINK_DOWN_DURING_TRANSMISSION  0x00000070U
+
+/* count of the times that a frame was discarded during link down */
+#define MSK_ETHMAC_LINK_DOWN_DURING_TRANSMISSION_CNT  0xffffffffU
+#define SRT_ETHMAC_LINK_DOWN_DURING_TRANSMISSION_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_UTX_UNDERFLOW_DURING_TRANSMISSION */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_UTX_UNDERFLOW_DURING_TRANSMISSION  0x00000074U
+
+/* UTX FIFO underflow at transmission time */
+#define MSK_ETHMAC_UTX_UNDERFLOW_DURING_TRANSMISSION_CNT  0xffffffffU
+#define SRT_ETHMAC_UTX_UNDERFLOW_DURING_TRANSMISSION_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_IN_FRAMES_OKAY */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_IN_FRAMES_OKAY  0x00000078U
+
+/* count of frames that are received without any error */
+#define MSK_ETHMAC_IN_FRAMES_OKAY_CNT  0xffffffffU
+#define SRT_ETHMAC_IN_FRAMES_OKAY_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_IN_OCTETS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_IN_OCTETS  0x0000007cU
+
+/* count of bytes in valid MAC frames received excluding Preamble, SFD and FCS */
+#define MSK_ETHMAC_IN_OCTETS_CNT  0xffffffffU
+#define SRT_ETHMAC_IN_OCTETS_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_FRAME_CHECK_SEQUENCE_ERRORS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_FRAME_CHECK_SEQUENCE_ERRORS  0x00000080U
+
+/* count of frames that are an integral number of octets in length and do not pass the FCS check */
+#define MSK_ETHMAC_FRAME_CHECK_SEQUENCE_ERRORS_CNT  0xffffffffU
+#define SRT_ETHMAC_FRAME_CHECK_SEQUENCE_ERRORS_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_ALIGNMENT_ERRORS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_ALIGNMENT_ERRORS  0x00000084U
+
+/* count of frames that are not an integral number of octets in length and do not pass the FCS check */
+#define MSK_ETHMAC_ALIGNMENT_ERRORS_CNT  0xffffffffU
+#define SRT_ETHMAC_ALIGNMENT_ERRORS_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_FRAME_TOO_LONG_ERRORS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_FRAME_TOO_LONG_ERRORS  0x00000088U
+
+/* count of frames that are received and exceed the maximum permitted frame size */
+#define MSK_ETHMAC_FRAME_TOO_LONG_ERRORS_CNT  0xffffffffU
+#define SRT_ETHMAC_FRAME_TOO_LONG_ERRORS_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_RUNT_FRAMES_RECEIVED */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_RUNT_FRAMES_RECEIVED  0x0000008cU
+
+/* count of frames that have a length between 42..63 bytes and an valid CRC */
+#define MSK_ETHMAC_RUNT_FRAMES_RECEIVED_CNT  0xffffffffU
+#define SRT_ETHMAC_RUNT_FRAMES_RECEIVED_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_COLLISION_FRAGMENTS_RECEIVED */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_COLLISION_FRAGMENTS_RECEIVED  0x00000090U
+
+/* count of frames that are smaller than 64 bytes and have an invalid CRC */
+#define MSK_ETHMAC_COLLISION_FRAGMENTS_RECEIVED_CNT  0xffffffffU
+#define SRT_ETHMAC_COLLISION_FRAGMENTS_RECEIVED_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_FRAMES_DROPPED_DUE_LOW_RESOURCE */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_FRAMES_DROPPED_DUE_LOW_RESOURCE  0x00000094U
+
+/* no empty pointer available at indication time */
+#define MSK_ETHMAC_FRAMES_DROPPED_DUE_LOW_RESOURCE_CNT  0xffffffffU
+#define SRT_ETHMAC_FRAMES_DROPPED_DUE_LOW_RESOURCE_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_FRAMES_DROPPED_DUE_URX_OVERFLOW */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_FRAMES_DROPPED_DUE_URX_OVERFLOW  0x00000098U
+
+/* URX FIFO overflow at indication time */
+#define MSK_ETHMAC_FRAMES_DROPPED_DUE_URX_OVERFLOW_CNT  0xffffffffU
+#define SRT_ETHMAC_FRAMES_DROPPED_DUE_URX_OVERFLOW_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_TX_FATAL_ERROR */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_TX_FATAL_ERROR  0x0000009cU
+
+/* counts unknown error numbers from TX xMAC, should never occur */
+#define MSK_ETHMAC_TX_FATAL_ERROR_CNT  0xffffffffU
+#define SRT_ETHMAC_TX_FATAL_ERROR_CNT            0
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_RX_FATAL_ERROR */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_RX_FATAL_ERROR  0x000000a0U
+
+/* counts unknown error numbers from RX xMAC, should never occur */
+#define MSK_ETHMAC_RX_FATAL_ERROR_CNT  0xffffffffU
+#define SRT_ETHMAC_RX_FATAL_ERROR_CNT            0
+
+
+/* ===================================================================== */
+/* Area ETHMAC_TXBUF */
+/* ===================================================================== */
+
+#define REL_Adr_AREA_ETHMAC_TXBUF  0x000000a4U
+
+/* ===================================================================== */
+/* Area ETHMAC_RXBUF */
+/* ===================================================================== */
+
+#define REL_Adr_AREA_ETHMAC_RXBUF  0x000006a4U
+
+/* ===================================================================== */
+/* Area ETHMAC_MULTICAST_FILTER_TABLE */
+/* ===================================================================== */
+
+#define REL_Adr_AREA_ETHMAC_MULTICAST_FILTER_TABLE  0x00000ca4U
+
+/* ===================================================================== */
+/* Area ETHMAC_TS_COR */
+/* ===================================================================== */
+
+#define REL_Adr_AREA_ETHMAC_TS_COR  0x00000ea4U
+
+/* ===================================================================== */
+/* Area ETHMAC_RESERVED */
+/* ===================================================================== */
+
+#define REL_Adr_AREA_ETHMAC_RESERVED  0x00000eacU
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_XPEC2ARM_INTERRUPTS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_XPEC2ARM_INTERRUPTS  0x00000eacU
+
+/* 1 */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_IND_HI  0x00000001U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_IND_HI            0
+
+/* 1 */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_IND_LO  0x00000002U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_IND_LO            1
+
+/* 1 */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_CON_HI  0x00000004U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_CON_HI            2
+
+/* 1 */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_CON_LO  0x00000008U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_CON_LO            3
+
+/* 1 */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_LINK_CHANGED  0x00000010U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_LINK_CHANGED            4
+
+/* 1 */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_COL  0x00000020U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_COL            5
+
+/* 1 */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_EARLY_RCV  0x00000040U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_EARLY_RCV            6
+
+/* 1 */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_RX_ERR  0x00000080U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_RX_ERR            7
+
+/* 1 */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_TX_ERR  0x00000100U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_TX_ERR            8
+
+/* reserved */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_RES1  0x0000fe00U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_RES1            9
+
+/* arm2xpec interrupts */
+#define MSK_ETHMAC_XPEC2ARM_INTERRUPTS_UNUSABLE  0xffff0000U
+#define SRT_ETHMAC_XPEC2ARM_INTERRUPTS_UNUSABLE           16
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_ARM2XPEC_INTERRUPTS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_ARM2XPEC_INTERRUPTS  0x00000eb0U
+
+/* xpec2arm interrupts */
+#define MSK_ETHMAC_ARM2XPEC_INTERRUPTS_UNUSABLE  0x0000ffffU
+#define SRT_ETHMAC_ARM2XPEC_INTERRUPTS_UNUSABLE            0
+
+/* 1 */
+#define MSK_ETHMAC_ARM2XPEC_INTERRUPTS_LINK_MODE_UPDATE_REQ  0x00010000U
+#define SRT_ETHMAC_ARM2XPEC_INTERRUPTS_LINK_MODE_UPDATE_REQ           16
+
+/* 1 */
+#define MSK_ETHMAC_ARM2XPEC_INTERRUPTS_VALID  0x00020000U
+#define SRT_ETHMAC_ARM2XPEC_INTERRUPTS_VALID           17
+
+/* 1 */
+#define MSK_ETHMAC_ARM2XPEC_INTERRUPTS_SPEED100  0x00040000U
+#define SRT_ETHMAC_ARM2XPEC_INTERRUPTS_SPEED100           18
+
+/* 1 */
+#define MSK_ETHMAC_ARM2XPEC_INTERRUPTS_FDX  0x00080000U
+#define SRT_ETHMAC_ARM2XPEC_INTERRUPTS_FDX           19
+
+/* reserved */
+#define MSK_ETHMAC_ARM2XPEC_INTERRUPTS_RES1  0xfff00000U
+#define SRT_ETHMAC_ARM2XPEC_INTERRUPTS_RES1           20
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_FIFO_ELEMENT */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_FIFO_ELEMENT  0x00000eb4U
+
+/* frame length */
+#define MSK_ETHMAC_FIFO_ELEMENT_FRAME_LEN  0x000007ffU
+#define SRT_ETHMAC_FIFO_ELEMENT_FRAME_LEN            0
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_FIFO_ELEMENT_RES1  0x00000800U
+#define SRT_ETHMAC_FIFO_ELEMENT_RES1           11
+
+/* 1 */
+#define MSK_ETHMAC_FIFO_ELEMENT_MULTI_REQ  0x00003000U
+#define SRT_ETHMAC_FIFO_ELEMENT_MULTI_REQ           12
+
+/* empty */
+#define MSK_ETHMAC_FIFO_ELEMENT_SUPPRESS_CON  0x00004000U
+#define SRT_ETHMAC_FIFO_ELEMENT_SUPPRESS_CON           14
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_FIFO_ELEMENT_RES2  0x00008000U
+#define SRT_ETHMAC_FIFO_ELEMENT_RES2           15
+
+/* frame buffer number */
+#define MSK_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM  0x003f0000U
+#define SRT_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM           16
+
+/* internal RAM segment number */
+#define MSK_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM  0x03c00000U
+#define SRT_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM           22
+
+/* reserved, shall be set to zero */
+#define MSK_ETHMAC_FIFO_ELEMENT_RES3  0x0c000000U
+#define SRT_ETHMAC_FIFO_ELEMENT_RES3           26
+
+/* error code */
+#define MSK_ETHMAC_FIFO_ELEMENT_ERROR_CODE  0xf0000000U
+#define SRT_ETHMAC_FIFO_ELEMENT_ERROR_CODE           28
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_HELP */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_HELP  0x00000eb8U
+
+/* 1 */
+#define MSK_ETHMAC_HELP_RX_IND_PRIO  0x00000001U
+#define SRT_ETHMAC_HELP_RX_IND_PRIO            0
+
+/* 1 */
+#define MSK_ETHMAC_HELP_RX_DROP  0x00000002U
+#define SRT_ETHMAC_HELP_RX_DROP            1
+
+/* 1 */
+#define MSK_ETHMAC_HELP_RX_FRWD2LOCAL  0x00000004U
+#define SRT_ETHMAC_HELP_RX_FRWD2LOCAL            2
+
+/* reserved */
+#define MSK_ETHMAC_HELP_RES1  0x000000f8U
+#define SRT_ETHMAC_HELP_RES1            3
+
+/* 1 */
+#define MSK_ETHMAC_HELP_TX_REQ_PRIO  0x00000100U
+#define SRT_ETHMAC_HELP_TX_REQ_PRIO            8
+
+/* reserved */
+#define MSK_ETHMAC_HELP_RES2  0xfffffe00U
+#define SRT_ETHMAC_HELP_RES2            9
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_SR_LINK_MODE */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_SR_LINK_MODE  0x00000ebcU
+
+/* 1 */
+#define MSK_ETHMAC_SR_LINK_MODE_VALID  0x00000001U
+#define SRT_ETHMAC_SR_LINK_MODE_VALID            0
+
+/* 1 */
+#define MSK_ETHMAC_SR_LINK_MODE_SPEED100  0x00000002U
+#define SRT_ETHMAC_SR_LINK_MODE_SPEED100            1
+
+/* 1 */
+#define MSK_ETHMAC_SR_LINK_MODE_FDX  0x00000004U
+#define SRT_ETHMAC_SR_LINK_MODE_FDX            2
+
+/* reserved */
+#define MSK_ETHMAC_SR_LINK_MODE_RES2  0x0000fff8U
+#define SRT_ETHMAC_SR_LINK_MODE_RES2            3
+
+/* unusable */
+#define MSK_ETHMAC_SR_LINK_MODE_UNUSABLE  0xffff0000U
+#define SRT_ETHMAC_SR_LINK_MODE_UNUSABLE           16
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_SR_CONFIG */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_SR_CONFIG  0x00000ec0U
+
+/* error code at transmission */
+#define MSK_ETHMAC_SR_CONFIG_ERROR_CODE  0x00000007U
+#define SRT_ETHMAC_SR_CONFIG_ERROR_CODE            0
+
+/* res */
+#define MSK_ETHMAC_SR_CONFIG_RES1  0x00003ff8U
+#define SRT_ETHMAC_SR_CONFIG_RES1            3
+
+/* 1 */
+#define MSK_ETHMAC_SR_CONFIG_TIMESTAMP_VALID  0x00004000U
+#define SRT_ETHMAC_SR_CONFIG_TIMESTAMP_VALID           14
+
+/* 0- */
+#define MSK_ETHMAC_SR_CONFIG_START  0x00008000U
+#define SRT_ETHMAC_SR_CONFIG_START           15
+
+/* unusable */
+#define MSK_ETHMAC_SR_CONFIG_UNUSABLE  0xffff0000U
+#define SRT_ETHMAC_SR_CONFIG_UNUSABLE           16
+
+
+/* --------------------------------------------------------------------- */
+/* Register ETHMAC_SR_STATUS */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_ETHMAC_SR_STATUS  0x00000ec4U
+
+/* received frame length */
+#define MSK_ETHMAC_SR_STATUS_RCVD_LEN  0x000007ffU
+#define SRT_ETHMAC_SR_STATUS_RCVD_LEN            0
+
+/* reserved */
+#define MSK_ETHMAC_SR_STATUS_RES  0x00000800U
+#define SRT_ETHMAC_SR_STATUS_RES           11
+
+/* error code at reception */
+#define MSK_ETHMAC_SR_STATUS_ERROR_CODE  0x00007000U
+#define SRT_ETHMAC_SR_STATUS_ERROR_CODE           12
+
+/* reception finished */
+#define MSK_ETHMAC_SR_STATUS_FIN  0x00008000U
+#define SRT_ETHMAC_SR_STATUS_FIN           15
+
+/* unusable */
+#define MSK_ETHMAC_SR_STATUS_UNUSABLE  0xffff0000U
+#define SRT_ETHMAC_SR_STATUS_UNUSABLE           16
+
+
+typedef struct ETHMAC_TXAREABASE_Ttag
+{
+  volatile uint32_t ulETHMAC_TX_RETRY;
+  volatile uint32_t ulETHMAC_TX_TIMESTAMP_NS;
+  volatile uint32_t ulETHMAC_TX_TIMESTAMP_S;
+} ETHMAC_TXAREABASE_T;
+
+typedef struct ETHMAC_RXAREABASE_Ttag
+{
+  volatile uint32_t ulETHMAC_RX_TIMESTAMP_NS;
+  volatile uint32_t ulETHMAC_RX_TIMESTAMP_S;
+} ETHMAC_RXAREABASE_T;
+
+typedef struct ETHMAC_CONFIG_AREA_BASE_Ttag
+{
+  volatile uint32_t ulETHMAC_MONITORING_MODE;
+  volatile uint32_t ulETHMAC_TRAFFIC_CLASS_ARRANGEMENT;
+  volatile uint32_t ulETHMAC_INTERRUPTS_ENABLE_IND_HI;
+  volatile uint32_t ulETHMAC_INTERRUPTS_ENABLE_IND_LO;
+  volatile uint32_t ulETHMAC_INTERRUPTS_ENABLE_CON_HI;
+  volatile uint32_t ulETHMAC_INTERRUPTS_ENABLE_CON_LO;
+  volatile uint32_t ulETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED;
+  volatile uint32_t ulETHMAC_INTERRUPTS_ENABLE_COL;
+  volatile uint32_t ulETHMAC_INTERRUPTS_ENABLE_EARLY_RCV;
+  volatile uint32_t ulETHMAC_INTERRUPTS_ENABLE_RX_ERR;
+  volatile uint32_t ulETHMAC_INTERRUPTS_ENABLE_TX_ERR;
+  volatile uint32_t ulETHMAC_INTERFACE_MAC_ADDRESS_LO;
+  volatile uint32_t ulETHMAC_INTERFACE_MAC_ADDRESS_HI;
+  volatile uint32_t ulETHMAC_2ND_INTERFACE_MAC_ADDRESS_LO;
+  volatile uint32_t ulETHMAC_2ND_INTERFACE_MAC_ADDRESS_HI;
+  volatile uint32_t ulETHMAC_SYSTIME_BORDER_COPY_PLUS1;
+  volatile uint32_t ulETHMAC_TS_COR_BASE_TX;
+  volatile uint32_t ulETHMAC_TS_COR_BASE_RX;
+} ETHMAC_CONFIG_AREA_BASE_T;
+
+typedef struct ETHMAC_STATUS_AREA_BASE_Ttag
+{
+  volatile uint32_t ulETHMAC_OUT_FRAMES_OKAY;
+  volatile uint32_t ulETHMAC_OUT_OCTETS;
+  volatile uint32_t ulETHMAC_SINGLE_COLLISION_FRAMES;
+  volatile uint32_t ulETHMAC_MULTIPLE_COLLISION_FRAMES;
+  volatile uint32_t ulETHMAC_LATE_COLLISIONS;
+  volatile uint32_t ulETHMAC_LINK_DOWN_DURING_TRANSMISSION;
+  volatile uint32_t ulETHMAC_UTX_UNDERFLOW_DURING_TRANSMISSION;
+  volatile uint32_t ulETHMAC_IN_FRAMES_OKAY;
+  volatile uint32_t ulETHMAC_IN_OCTETS;
+  volatile uint32_t ulETHMAC_FRAME_CHECK_SEQUENCE_ERRORS;
+  volatile uint32_t ulETHMAC_ALIGNMENT_ERRORS;
+  volatile uint32_t ulETHMAC_FRAME_TOO_LONG_ERRORS;
+  volatile uint32_t ulETHMAC_RUNT_FRAMES_RECEIVED;
+  volatile uint32_t ulETHMAC_COLLISION_FRAGMENTS_RECEIVED;
+  volatile uint32_t ulETHMAC_FRAMES_DROPPED_DUE_LOW_RESOURCE;
+  volatile uint32_t ulETHMAC_FRAMES_DROPPED_DUE_URX_OVERFLOW;
+  volatile uint32_t ulETHMAC_TX_FATAL_ERROR;
+  volatile uint32_t ulETHMAC_RX_FATAL_ERROR;
+} ETHMAC_STATUS_AREA_BASE_T;
+
+typedef struct ETHMAC_TXBUF_Ttag
+{
+  volatile uint32_t aulDataField[384];
+} ETHMAC_TXBUF_T;
+
+typedef struct ETHMAC_RXBUF_Ttag
+{
+  volatile uint32_t aulDataField[384];
+} ETHMAC_RXBUF_T;
+
+typedef struct ETHMAC_MULTICAST_FILTER_TABLE_Ttag
+{
+  volatile uint32_t aulDataField[128];
+} ETHMAC_MULTICAST_FILTER_TABLE_T;
+
+typedef struct ETHMAC_TS_COR_Ttag
+{
+  volatile uint32_t aulDataField[2];
+} ETHMAC_TS_COR_T;
+
+typedef struct ETHMAC_XPEC_DPMtag {
+  ETHMAC_TXAREABASE_T tETHMAC_TXAREABASE;
+  ETHMAC_RXAREABASE_T tETHMAC_RXAREABASE;
+  ETHMAC_CONFIG_AREA_BASE_T tETHMAC_CONFIG_AREA_BASE;
+  ETHMAC_STATUS_AREA_BASE_T tETHMAC_STATUS_AREA_BASE;
+  ETHMAC_TXBUF_T tETHMAC_TXBUF;
+  ETHMAC_RXBUF_T tETHMAC_RXBUF;
+  ETHMAC_MULTICAST_FILTER_TABLE_T tETHMAC_MULTICAST_FILTER_TABLE;
+  ETHMAC_TS_COR_T tETHMAC_TS_COR;
+} ETHMAC_XPEC_DPM;
+
+#endif /* ethmac_xpec_regdef_h__ */
+
diff --git a/drivers/net/ethernet/netx4000/mdio-xc-netx4000.c b/drivers/net/ethernet/netx4000/mdio-xc-netx4000.c
new file mode 100644
index 000000000000..df99a6bdeb47
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/mdio-xc-netx4000.c
@@ -0,0 +1,392 @@
+/*
+* MDIO XC driver for Hilscher netx4000 based platforms
+*
+* drivers/net/phy/mdio-netx4000.c
+*
+* (C) Copyright 2015 Hilscher Gesellschaft fuer Systemautomation mbH
+* http://www.hilscher.com
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of
+* the License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+*/
+
+#define DRIVER_DESC "MDIO XC driver for Hilscher netX4000 based platforms"
+#define DRIVER_NAME "mdio-xc-netx4000"
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <linux/ioport.h>
+#include <asm/io.h>
+
+
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#include <linux/mdio-bitbang.h>
+
+#include <linux/delay.h>
+
+#define INTPHY0_ID  0
+#define INTPHY1_ID  1
+
+/* Regdef */
+
+#define regdef(mask,shift,name) \
+static inline int g##name(int val) { \
+	return (val >> shift) & mask; \
+} \
+static inline int s##name(int val) { \
+	return (val & mask) << shift; \
+}
+
+#define ASIC_CTRL_ACCESS_KEY		0xf408017c
+
+#define CLOCK_ENABLE				0xf4080138
+regdef (0x1, 16, XC_MISC)
+regdef (0xff, 0, MMIO_SEL)
+
+#define PHY_CONTROL					0xf4023a20
+regdef (0x1, 31, PHY_RESET)
+regdef (0x1, 30, PHY_SIM_BYP)
+regdef (0x1, 18, PHY1_AUTOMDIX)
+regdef (0x1, 17, PHY1_FXMODE)
+regdef (0x1, 16, PHY1_ENABLE)
+regdef (0x1, 10, PHY0_AUTOMDIX)
+regdef (0x1,  9, PHY0_FXMODE)
+regdef (0x1,  8, PHY0_ENABLE)
+regdef (0xf,  0, PHY_MODE)
+
+#define INT_PHY_CTRL0				0xf4023a90
+#define INT_PHY_CTRL1				0xf4023aa0
+#define INT_PHY_CTRL2				0xf4023ab0
+#define INT_PHY_CTRL3				0xf4023ac0
+#define INT_PHY_CTRLx_SIZE			0x10
+
+#define INT_PHY_CTRL_MIIMU(base)					(base+0x0)
+#define INT_PHY_CTRL_MIIMU_SW(base)					(base+0x4)
+regdef (0x1,  7, MDI_RO)
+regdef (0x1,  6, MDOE)
+regdef (0x1,  5, MDO)
+regdef (0x1,  4, MDC)
+regdef (0x1,  0, SW_MODE_ENABLE)
+
+#define INT_PHY_CTRL_LED(base)						(base+0x8)
+regdef (0xf, 12, LED_FLASH_INTERVAL)
+regdef (0x3,  8, LED_MODE)
+regdef (0x1,  7, LED1)
+regdef (0x1,  6, LED0)
+regdef (0x1,  5, SPEED100_RO)
+regdef (0x1,  4, SPEED10_RO)
+regdef (0x1,  3, LINK_RO)
+regdef (0x1,  2, DUPLEX_RO)
+regdef (0x1,  1, TX_ACTIVE_RO)
+regdef (0x1,  0, RX_ACTIVE_RO)
+
+#define INT_PHY_CTRL_ENHANCED_LINK_DETECTION(base)	(base+0xc)
+
+struct platform_data {
+	struct resource res;
+	uint32_t intphy_id;
+};
+
+static struct platform_data netx4000_mdio_xc[] = {
+	{
+		.res = DEFINE_RES_MEM(INT_PHY_CTRL0, INT_PHY_CTRLx_SIZE),
+		.intphy_id = INTPHY0_ID,
+	},
+{
+		.res = DEFINE_RES_MEM(INT_PHY_CTRL1, INT_PHY_CTRLx_SIZE),
+		.intphy_id = INTPHY1_ID,
+	},
+	{
+		.res = DEFINE_RES_MEM(INT_PHY_CTRL2, INT_PHY_CTRLx_SIZE),
+		.intphy_id = -1, /* only external PHYs are supported */
+	},
+	{
+		.res = DEFINE_RES_MEM(INT_PHY_CTRL3, INT_PHY_CTRLx_SIZE),
+		.intphy_id = -1, /* only external PHYs are supported */
+	},
+};
+
+struct priv_data {
+	struct device *dev;
+	struct platform_data *data;
+	struct mdiobb_ctrl ctrl;
+	void __iomem *base;
+	uint32_t intphy_id;
+};
+
+static void mdio_dir(struct mdiobb_ctrl *ctrl, int dir)
+{
+	struct priv_data *priv = container_of(ctrl, struct priv_data, ctrl);
+	struct device *dev = priv->dev;
+	uint32_t val32;
+
+	dev_dbg(dev, "%s: +++ (*ctrl=%p, dir=%i)\n", __func__, ctrl, dir);
+
+	val32 = ioread32(INT_PHY_CTRL_MIIMU_SW(priv->base));
+	if (dir)
+		iowrite32(val32 | sMDOE(1), INT_PHY_CTRL_MIIMU_SW(priv->base));
+	else
+		iowrite32(val32 & ~sMDOE(1), INT_PHY_CTRL_MIIMU_SW(priv->base));
+}
+
+static int mdio_get(struct mdiobb_ctrl *ctrl)
+{
+	struct priv_data *priv = container_of(ctrl, struct priv_data, ctrl);
+	struct device *dev = priv->dev;
+	uint32_t val32;
+
+	dev_dbg(dev, "%s: +++ (*ctrl=%p)\n", __func__, ctrl);
+
+	val32 = ioread32(INT_PHY_CTRL_MIIMU_SW(priv->base));
+
+	return (val32 & sMDI_RO(1)) ? 1 : 0;
+}
+
+static void mdio_set(struct mdiobb_ctrl *ctrl, int what)
+{
+	struct priv_data *priv = container_of(ctrl, struct priv_data, ctrl);
+	struct device *dev = priv->dev;
+	uint32_t val32;
+
+	dev_dbg(dev, "%s: +++ (*ctrl=%p, what=%i)\n", __func__, ctrl, what);
+
+	val32 = ioread32(INT_PHY_CTRL_MIIMU_SW(priv->base));
+	if (what)
+		iowrite32(val32 | sMDO(1), INT_PHY_CTRL_MIIMU_SW(priv->base));
+	else
+		iowrite32(val32 & ~sMDO(1), INT_PHY_CTRL_MIIMU_SW(priv->base));
+}
+
+static void mdc_set(struct mdiobb_ctrl *ctrl, int what)
+{
+	struct priv_data *priv = container_of(ctrl, struct priv_data, ctrl);
+	struct device *dev = priv->dev;
+	uint32_t val32;
+
+	dev_dbg(dev, "%s: +++ (*ctrl=%p, what=%i)\n", __func__, ctrl, what);
+
+	val32 = ioread32(INT_PHY_CTRL_MIIMU_SW(priv->base));
+	if (what)
+		iowrite32(val32 | sMDC(1), INT_PHY_CTRL_MIIMU_SW(priv->base));
+	else
+		iowrite32(val32 & ~sMDC(1), INT_PHY_CTRL_MIIMU_SW(priv->base));
+}
+
+static struct mdiobb_ops netx4000_mdio_ops = {
+	.set_mdc = mdc_set,
+	.set_mdio_dir = mdio_dir,
+	.set_mdio_data = mdio_set,
+	.get_mdio_data = mdio_get,
+};
+
+static int netx4000_mdio_intphy_init(struct priv_data *priv)
+{
+	struct device *dev = priv->dev;
+	struct device_node *phy_node;
+	uint32_t val32, addr;
+	char *p8 = NULL;
+	volatile uint32_t* io_addr;
+
+	dev_dbg(dev, "%s: +++ (*priv=%p)\n", __func__, priv);
+
+	/* Check for phy node */
+	phy_node = of_find_node_by_name( dev->of_node ,"phy");
+	if (!phy_node) {
+		dev_err(dev, "Invalid or missing '/phy' node in DT!\n");
+		return -EINVAL;
+	}
+
+	/* Check if PHY is declared as internal PHY */
+	of_property_read_string(phy_node, "phy-mode", (const char**)&p8);
+	if (!p8 || strcmp("internal", p8)) {
+		dev_err(dev, "External PHYs currently not supported!\n");
+		return -ENOTSUPP;
+	}
+
+	/* Check if PHY ID matched to MDIO interface */
+	of_property_read_u32(phy_node, "reg", &addr);
+	if (addr != priv->intphy_id) {
+		dev_err(dev, "Invalid or missing PHY ID!\n");
+		return -EINVAL;
+	}
+
+	if (priv->intphy_id == INTPHY0_ID) {
+		io_addr = ioremap(PHY_CONTROL, sizeof(io_addr));
+		val32 = ioread32(io_addr);
+		iowrite32(val32|sPHY0_ENABLE(1)|sPHY0_AUTOMDIX(1), io_addr);
+		iounmap(io_addr);
+	}
+	else if (priv->intphy_id == INTPHY1_ID) {
+		io_addr = ioremap(PHY_CONTROL, sizeof(io_addr));
+		val32 = ioread32(io_addr);
+		iowrite32(val32|sPHY1_ENABLE(1)|sPHY1_AUTOMDIX(1), io_addr);
+		iounmap(io_addr);
+	}
+	io_addr = ioremap(PHY_CONTROL, sizeof(*io_addr));
+
+	/* Enable software mode */
+	val32 = ioread32(INT_PHY_CTRL_MIIMU_SW(priv->base));
+	iowrite32(val32|sSW_MODE_ENABLE(1), INT_PHY_CTRL_MIIMU_SW(priv->base));
+
+	/* Enable static LED mode */
+	iowrite32(sLED_MODE(0x01 /* static */), INT_PHY_CTRL_LED(priv->base));
+
+	/* Deassert PHY reset / Enable Auto-Negotiation */
+	val32 = (ioread32(io_addr) & ~(sPHY_RESET(1)|sPHY_MODE(0xF))) |
+			sPHY_MODE(0x7 /* advertise all */);
+	iowrite32(val32|sPHY_RESET(1), io_addr);
+	msleep(100);
+	iowrite32(val32, io_addr);
+
+	iounmap(io_addr);
+
+	return 0;
+}
+
+int counter=0;
+
+static int netx4000_mdio_probe(struct platform_device *pdev)
+{
+	struct priv_data *priv;
+	struct mii_bus *bus;
+	int rc;
+	struct device *dev = &pdev->dev;
+	volatile uint32_t* clock_addr;
+	volatile uint32_t* key_addr;
+	uint32_t keyval, val32;
+
+	dev_dbg(dev, "%s: +++ (*dev=%p)\n", __func__, pdev);
+
+	priv = kzalloc(sizeof(*priv),GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = dev;
+	priv->data = dev_get_drvdata(&pdev->dev);
+	if (priv->data) {
+		struct resource *res;
+
+		/* Using platform data */
+		res = request_mem_region( priv->data->res.start, priv->data->res.end - priv->data->res.start, dev_name(dev));
+		if (IS_ERR(res)) {
+			rc = -EIO;
+			goto err_out;
+		}
+		priv->base = ioremap( res->start, resource_size(res));
+
+		priv->intphy_id = priv->data->intphy_id;
+	}
+	else {
+		struct resource res;
+
+		/* Using devicetree data */
+		if (0 == of_address_to_resource( dev->of_node, 0, &res)) {
+			priv->base = ioremap( res.start, resource_size(&res));
+		}
+		if (IS_ERR_OR_NULL(priv->base)){
+			dev_err(dev, "Invalid or missing 'reg' node in DT!\n");
+			rc = PTR_ERR(priv->base);
+			goto err_out;
+		}
+
+		priv->intphy_id = -1;
+		rc = of_property_read_u32(dev->of_node, "intphy_id", &priv->intphy_id);
+		if (!rc) {
+			dev_dbg(dev, "Invalid or missing 'intphy_id' node in DT!\n");
+		}
+	}
+
+	priv->ctrl.ops = &netx4000_mdio_ops;
+
+	bus = alloc_mdio_bitbang(&priv->ctrl);
+	bus->parent = dev;
+	bus->dev.of_node = dev->of_node;
+	++counter;
+	bus->name = kzalloc(strlen("mdio-int")+2, GFP_KERNEL);
+	sprintf((char*)bus->name, "mdio-int%d", counter);
+	sprintf(bus->id, "%X", 0x23 + counter);
+
+	//dev->p = bus;
+
+	/* Enable clock for global XC logic */
+	clock_addr = ioremap(CLOCK_ENABLE, sizeof(clock_addr));
+	val32 = ioread32(clock_addr);
+	key_addr = ioremap(ASIC_CTRL_ACCESS_KEY, sizeof(key_addr));
+	keyval = ioread32(key_addr);
+	iowrite32(keyval, key_addr);
+	iowrite32(val32|sXC_MISC(1), clock_addr);
+	iounmap(clock_addr);
+	iounmap(key_addr);
+
+	/* Preparing for internal PHYs if configured in DT */
+	rc = netx4000_mdio_intphy_init(priv);
+	if (rc)
+		goto err_out;
+
+	rc = mdiobus_register(bus);
+	if (rc) {
+		printk("mdiobus regisater %d failed\n", rc);
+		dev_err(dev, "Initializing failed!\n");
+		goto err_out;
+	}
+
+	return 0;
+
+err_out:
+	if (bus != NULL)
+		kfree(bus);
+	kfree(priv);
+
+	return rc;
+}
+
+static const struct of_device_id netx4000_mdio_dt_ids[] = {
+	{ .compatible = "hilscher,netx4000-mdio-xc", .data = NULL },
+	{ .compatible = "hilscher,netx4000-mdio-xc0", .data = &netx4000_mdio_xc[0] },
+	{ .compatible = "hilscher,netx4000-mdio-xc1", .data = &netx4000_mdio_xc[1] },
+	{ .compatible = "hilscher,netx4000-mdio-xc2", .data = &netx4000_mdio_xc[2] },
+	{ .compatible = "hilscher,netx4000-mdio-xc3", .data = &netx4000_mdio_xc[3] },
+	{ /* sentinel */ }
+};
+
+static struct platform_driver netx4000_mdio_driver = {
+	.probe = netx4000_mdio_probe,
+	.driver = {
+		.name = "netx4000-mdio-xc",
+		.owner = THIS_MODULE,
+		.of_match_table = netx4000_mdio_dt_ids,
+	},
+};
+
+static int __init netx4000_mdio_init(void)
+{
+	pr_info("%s: %s\n", DRIVER_NAME, DRIVER_DESC);
+	return platform_driver_register(&netx4000_mdio_driver);
+}
+
+static void __exit netx4000_mdio_exit(void)
+{
+	pr_info("de-registering %s: %s\n", DRIVER_NAME, DRIVER_DESC);
+	platform_driver_unregister(&netx4000_mdio_driver);
+}
+
+module_init(netx4000_mdio_init);
+module_exit(netx4000_mdio_exit);
+
+/* --- Module information --- */
+
+MODULE_AUTHOR("Hilscher Gesellschaft fuer Systemautomation mbH");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/netx4000/netx4000-eth.c b/drivers/net/ethernet/netx4000/netx4000-eth.c
new file mode 100644
index 000000000000..f1ecb88a0bd8
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/netx4000-eth.c
@@ -0,0 +1,590 @@
+/*
+* MDIO XC driver for Hilscher netx4000 based platforms
+*
+* drivers/net/ethernet/netx4000-eth.c
+*
+* (C) Copyright 2015 Hilscher Gesellschaft fuer Systemautomation mbH
+* http://www.hilscher.com
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of
+* the License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_mdio.h>
+#include <linux/interrupt.h>
+#include <linux/phy.h>
+
+#include <linux/list.h>
+
+#include "netx4000-xc.h"
+#include "netx4000-xceth-hal.h"
+
+#define MSK_ETHMAC_IRQ_IND_HI        0x00000001U
+#define MSK_ETHMAC_IRQ_IND_LO        0x00000002U
+#define MSK_ETHMAC_IRQ_CON_HI        0x00000004U
+#define MSK_ETHMAC_IRQ_CON_LO        0x00000008U
+#define MSK_ETHMAC_IRQ_LINK_CHANGED  0x00000010U
+#define MSK_ETHMAC_IRQ_COL           0x00000020U
+#define MSK_ETHMAC_IRQ_EARLY_RCV     0x00000040U
+#define MSK_ETHMAC_IRQ_RX_ERR        0x00000080U
+#define MSK_ETHMAC_IRQ_TX_ERR        0x00000100U
+
+#define RESERVED_SEND_BUFFER 4
+
+struct send_buffer {
+	struct list_head list;
+
+	ETHERNET_FRAME_T *ptFrame;
+	void* hFrame;
+};
+
+struct netx_eth_priv {
+	int portno;
+	uint32_t msg_enable;
+	struct port* port;
+	spinlock_t lock;
+	struct phy_device* phy;
+	struct device* dev;
+	struct mii_if_info mii_if;
+
+	struct list_head txdesc_free;
+	struct list_head txdesc_used;
+};
+
+static void netx_eth_ethtool_getdrvinfo(struct net_device *ndev, struct ethtool_drvinfo *ed)
+{
+	/* FIXME: Insert reasonable driver informations! */
+	strlcpy(ed->driver, "netx4000-xceth", sizeof(ed->driver));
+	strlcpy(ed->version, "6.2.0.2", sizeof(ed->version));
+}
+
+static const struct ethtool_ops netx_xceth_ethtool_ops = {
+	/* FIXME: Check which function we should support! */
+	.get_drvinfo = netx_eth_ethtool_getdrvinfo,
+	.get_link = ethtool_op_get_link,
+	.get_link_ksettings = phy_ethtool_get_link_ksettings,
+	.set_link_ksettings = phy_ethtool_set_link_ksettings,
+};
+
+void netx_eth_ethtool_ops(struct net_device *netdev)
+{
+	netdev->ethtool_ops = &netx_xceth_ethtool_ops;
+}
+
+static void netx_eth_set_multicast_list(struct net_device *ndev)
+{
+	//TODO
+}
+
+static void netx_eth_set_rx_mode(struct net_device *ndev)
+{
+	struct netx_eth_priv *priv = netdev_priv(ndev);
+
+	if (ndev->flags & IFF_PROMISC) {
+		netx4000_xceth_mode_promisc( priv->portno, 1);
+	} else {
+		netx4000_xceth_mode_promisc( priv->portno, 0);
+	}
+	netx_eth_set_multicast_list( ndev);
+}
+
+static void netx_eth_timeout(struct net_device *ndev, unsigned int txqueue)
+{
+// 	struct netx_eth_priv *priv = netdev_priv(ndev);
+	//int i;
+
+	printk(KERN_ERR "%s: transmit timed out, resetting\n", ndev->name);
+	//spin_lock_irq(&priv->lock);
+	//printk(".... -> timeout \n");
+
+	//port_reset( priv->port);
+	//port_start( priv->port);
+
+	//for (i=2; i<=18; i++)
+	//	pfifo_push(EMPTY_PTR_FIFO(priv->id), FIFO_PTR_FRAMENO(i) | FIFO_PTR_SEGMENT(priv->id));
+
+	//spin_unlock_irq(&priv->lock);
+	netif_wake_queue(ndev);
+}
+
+static int netx_eth_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct netx_eth_priv *priv = netdev_priv(ndev);
+	struct send_buffer *txdesc;
+	uint32_t length = 0;
+	int ret = NETDEV_TX_BUSY;
+
+	spin_lock_irq(&priv->lock);
+
+	txdesc = list_first_entry_or_null(&priv->txdesc_free, struct send_buffer, list);
+	if (txdesc == NULL) {
+		netif_stop_queue(ndev);
+		ret = NETDEV_TX_BUSY;
+		goto exit;
+	}
+
+	memcpy_toio(txdesc->ptFrame, skb->data, skb->len);
+	length = skb->len;
+	if (skb->len < 60) {
+		memset((uint8_t*)txdesc->ptFrame + length, 0, 60 - skb->len);
+		length = 60;
+	}
+
+	ret = netx4000_xceth_send_frame(priv->port->portno, txdesc->hFrame, length, 0 /* LowPrio */);
+	if (ret) {
+		/* do not release frame here since we keep it all the time to make sure to have a resource to send */
+		dev_err(priv->dev,"error sending frame!\n");
+	}
+	else {
+		list_move_tail(priv->txdesc_free.next, &priv->txdesc_used);
+
+		ndev->stats.tx_packets++;
+		ndev->stats.tx_bytes += length;
+		ret = NETDEV_TX_OK;
+	}
+
+	dev_kfree_skb(skb);
+
+exit:
+	spin_unlock_irq(&priv->lock);
+
+	return ret;
+}
+
+static void netx_eth_receive(struct net_device *ndev)
+{
+	struct netx_eth_priv *priv = netdev_priv(ndev);
+	ETHERNET_FRAME_T *ptFrame = NULL;
+	void* hFrame = NULL;
+	uint32_t ulLen;
+	struct sk_buff *skb;
+	uint8_t *data;
+
+	do {
+		if (netx4000_xceth_recv_frame(priv->port->portno, &ptFrame, &hFrame, &ulLen, 0 /* LowPrio */))
+			break;
+
+		skb = netdev_alloc_skb(ndev, ulLen + 2);
+		if (unlikely(!skb)) {
+			netx4000_xceth_release_frame(priv->port->portno, hFrame);
+			ndev->stats.rx_dropped++;
+			printk(KERN_NOTICE "%s: Low memory, packet dropped.\n", ndev->name);
+			break;
+		}
+
+		skb_reserve(skb, 2); /* align IP on 16B boundary */
+		data = skb_put(skb, ulLen);
+
+		memcpy_fromio(data, ptFrame, ulLen);
+
+		netx4000_xceth_release_frame(priv->port->portno, hFrame);
+
+		skb->protocol = eth_type_trans(skb, ndev);
+
+		netif_rx(skb);
+
+		ndev->stats.rx_packets++;
+		ndev->stats.rx_bytes += ulLen;
+	} while (0);
+}
+
+static irqreturn_t netx_eth_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev = dev_id;
+	struct netx_eth_priv *priv = netdev_priv(ndev);
+	unsigned long flags;
+	int status;
+	uint32_t txlevel, rxlevel;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	status = netx4000_xceth_get_irq(priv->port->portno);
+	if (status) {
+		netx4000_xceth_confirm_irq(priv->port->portno, status);
+
+		netx4000_xceth_get_send_cnf_fill_level(priv->port->portno, 0 /* low prio */, &txlevel);
+		netx4000_xceth_get_recv_fill_level(priv->port->portno, 0 /* low prio */, &rxlevel);
+
+		if (status & (MSK_ETHMAC_IRQ_CON_HI | MSK_ETHMAC_IRQ_CON_LO)) {
+			while (txlevel--) {
+				struct send_buffer *txdesc;
+				uint32_t ulLength;
+				int rc;
+
+				txdesc = list_first_entry_or_null(&priv->txdesc_used, struct send_buffer, list);
+				if (txdesc) {
+					rc = netx4000_xceth_get_send_cnf(priv->port->portno, &txdesc->ptFrame, &txdesc->hFrame, &ulLength, 0 /* low prio */);
+					if (rc != -EBUSY) {
+						/* Confirmation frame received! */
+						list_move_tail(priv->txdesc_used.next, &priv->txdesc_free);
+						netif_wake_queue(ndev);
+
+						if (rc < -EIO)
+							ndev->stats.tx_errors++;
+					}
+				}
+				else
+					/* TODO: Error handling */
+					dev_err(priv->dev, "Unexpected confirmation frame received. Skipping IRQ!\n");
+			}
+		}
+
+		if (status & (MSK_ETHMAC_IRQ_IND_HI | MSK_ETHMAC_IRQ_IND_LO)) {
+			while (rxlevel--)
+				netx_eth_receive( ndev);
+		}
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static void netx4000_xceth_update_linkspeed(struct net_device *ndev)
+{
+	struct netx_eth_priv *priv = netdev_priv(ndev);
+
+	dev_dbg(priv->dev, "%s: called for %p\n", __func__, ndev);
+
+	port_set_link_mode(priv->port, ndev->phydev->link, ndev->phydev->speed, ndev->phydev->duplex);
+
+	phy_print_status(ndev->phydev);
+}
+
+static int netx4000_init_txdesc_lists(struct netx_eth_priv *priv)
+{
+	struct send_buffer *desc;
+	int i, rc;
+
+	INIT_LIST_HEAD(&priv->txdesc_free);
+	INIT_LIST_HEAD(&priv->txdesc_used);
+
+	for (i = 0; i < RESERVED_SEND_BUFFER; i++) {
+		desc = kmalloc(sizeof(*desc), GFP_KERNEL);
+		rc = netx4000_xceth_get_frame(priv->port->portno, &desc->ptFrame, &desc->hFrame);
+		if (rc) {
+			kfree(desc);
+			return -ENOMEM;
+		}
+		list_add_tail(&desc->list, &priv->txdesc_free);
+	}
+
+	return 0;
+}
+
+static void netx4000_free_txdesc_lists(struct netx_eth_priv *priv)
+{
+	struct send_buffer *desc, *desc_tmp;
+
+	/* Go through the txdesc lists and free related memory. */
+	list_for_each_entry_safe(desc, desc_tmp, &priv->txdesc_free, list) {
+		list_del(&desc->list);
+		netx4000_xceth_release_frame(priv->port->portno, desc->hFrame);
+		kfree(desc);
+	}
+	list_for_each_entry_safe(desc, desc_tmp, &priv->txdesc_used, list) {
+		list_del(&desc->list);
+		netx4000_xceth_release_frame(priv->port->portno, desc->hFrame);
+		kfree(desc);
+	}
+}
+
+static int netx_eth_open(struct net_device *ndev)
+{
+	struct netx_eth_priv *priv = netdev_priv(ndev);
+	int ret = 0;
+	struct device_node* phy_node = NULL;
+	phy_interface_t interface;
+
+	dev_dbg(priv->dev, "%s: called for %p\n", __func__, ndev);
+
+	ret = netx4000_init_txdesc_lists(priv);
+	if (ret) {
+		dev_err(priv->dev, "Failed to initialize txdesc lists!\n");
+		return ret;
+	}
+
+	netx4000_xceth_confirm_irq( priv->portno, 0xffffffff);
+	if ((ret = request_irq(ndev->irq, netx_eth_interrupt, 0, ndev->name, ndev)) != 0) {
+		dev_err(priv->dev, "%s: Failed to request irq %d (ret=%d)\n", __func__, ndev->irq, ret);
+		return -EAGAIN;
+	}
+	netx4000_xceth_set_irq( priv->portno, MSK_ETHMAC_INTERRUPTS_ENABLE_CON_LO_VAL |
+				MSK_ETHMAC_INTERRUPTS_ENABLE_CON_HI_VAL |
+				MSK_ETHMAC_INTERRUPTS_ENABLE_IND_LO_VAL |
+				MSK_ETHMAC_INTERRUPTS_ENABLE_IND_HI_VAL);
+
+	port_start(priv->port);
+
+	phy_node = of_parse_phandle(priv->dev->of_node, "phy-handle", 0);
+	of_get_phy_mode(phy_node, &interface);
+	if ((priv->phy = of_phy_connect( ndev, phy_node, netx4000_xceth_update_linkspeed, 0,  interface)) == NULL) {
+		dev_err(priv->dev, "%s: Failed to connect to phy\n", __func__);
+		ret =-EAGAIN;
+		goto err;
+	}
+	phy_attached_info(priv->phy);
+	phy_start( priv->phy);
+
+	netif_start_queue(ndev);
+
+	return 0;
+
+err:
+	port_stop(priv->port);
+
+	netx4000_xceth_set_irq( priv->portno, 0);
+	free_irq(ndev->irq, ndev);
+
+	netx4000_free_txdesc_lists(priv);
+
+	return ret;
+}
+
+static int netx_eth_close(struct net_device *ndev)
+{
+	struct netx_eth_priv *priv = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+
+	phy_stop( priv->phy);
+	phy_disconnect( priv->phy);
+
+	port_stop(priv->port);
+
+	netx4000_xceth_set_irq( priv->portno, 0);
+	free_irq(ndev->irq, ndev);
+
+	netx4000_free_txdesc_lists(priv);
+
+	return 0;
+}
+
+static int netx_eth_mac_addr(struct net_device *ndev, void *p)
+{
+	int rc = eth_mac_addr(ndev, p);
+
+	if(rc == 0) {
+		struct netx_eth_priv *priv = netdev_priv(ndev);
+		port_set_mac_addr(priv->port, ETH_MAC_ADDRESS_CHASSIS,
+				ndev->dev_addr);
+	}
+
+	return rc;
+}
+
+static const struct net_device_ops netx_eth_netdev_ops = {
+	.ndo_open = netx_eth_open,
+	.ndo_stop = netx_eth_close,
+	.ndo_start_xmit = netx_eth_hard_start_xmit,
+	.ndo_tx_timeout = netx_eth_timeout,
+	.ndo_set_rx_mode = netx_eth_set_rx_mode,
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_set_mac_address = netx_eth_mac_addr,
+};
+
+static int netx_eth_enable(struct net_device *ndev)
+{
+	struct netx_eth_priv *priv = netdev_priv(ndev);
+	int ret = 0;
+	u8 mac[ETH_ALEN];
+
+	ether_setup(ndev);
+
+	ndev->netdev_ops = &netx_eth_netdev_ops;
+	ndev->watchdog_timeo = msecs_to_jiffies(5000);
+
+	/* this function will also donwload the firmware if necessary */
+	priv->port = port_request( priv->portno, priv->dev);
+	if (priv->port == NULL) {
+		dev_dbg(priv->dev, "%s: requesting firmware failed %d\n", __func__, ret);
+		return -ENODEV;
+	}
+	netx4000_xceth_initFifoUnit( priv->portno);
+
+	/* Configure MAC address */
+	if (!of_get_mac_address(priv->dev->of_node, mac)) {
+		port_set_mac_addr( priv->port, ETH_MAC_ADDRESS_CHASSIS, mac);
+		memcpy( ndev->dev_addr, mac, 6);
+	} else {
+		dev_err(priv->dev, "Failed to get mac addr from device-tree!\n");
+	}
+	dev_dbg(priv->dev, "%s: Registering net device netx4000-xceth%u...\n", __func__, priv->portno);
+
+	return 0;
+}
+
+static void netx_eth_disable(struct net_device *ndev)
+{
+	struct netx_eth_priv *priv = netdev_priv(ndev);
+
+	if ( priv->port != NULL) {
+		port_free( priv->port);
+		priv->port = NULL;
+
+		netx4000_xceth_fifo_release( priv->portno);
+	}
+}
+
+int s_fifo_reset_done = 0;
+
+static int netx_eth_drv_probe(struct platform_device *pdev)
+{
+	struct netx_eth_priv *priv;
+	struct net_device *ndev;
+	int ret;
+
+	dev_dbg( &pdev->dev, "%s: probing netX4000 Ethernet device...\n",__func__);
+
+	ndev = alloc_etherdev(sizeof (struct netx_eth_priv));
+	if (!ndev) {
+		return -ENOMEM;
+	}
+	priv = netdev_priv(ndev);
+	priv->dev = &pdev->dev;
+	ndev->dev.parent = &pdev->dev;
+	ndev->irq = of_irq_get(pdev->dev.of_node, 0);
+	netx_eth_ethtool_ops(ndev);
+	spin_lock_init(&priv->lock);
+
+	if (0 != (ret = of_property_read_u32( pdev->dev.of_node, "port", &priv->portno))) {
+		dev_err( &pdev->dev, "%s: Failed to retrieve port information (ret=%d)\n",__func__, ret);
+		goto err;
+	}
+	/* the request is done global for instance 0 & 1 so make sure to do it only once */
+	if (netx4000_xceth_fifo_request( &ndev->dev, priv->portno)) {
+		ret = -EIO;
+		dev_err( &pdev->dev, "%s: Failed to request fifo!\n",__func__);
+		goto err;
+	}
+
+	do { /* Resetting pfifo only once per XC unit (2 ports) */
+		uint8_t xcNo = priv->portno >> 1;
+
+		if (s_fifo_reset_done & (1 << xcNo))
+			break;
+
+		s_fifo_reset_done |= (1 << xcNo);
+		netx4000_pfifo_reset(xcNo);
+	} while (0);
+
+	ret = netx_eth_enable(ndev);
+	if (ret<0) {
+		dev_err( &pdev->dev, "%s: Failed to enable ethernet device port %d\n",__func__, priv->portno);
+		goto err_enable;
+	}
+	if (!is_valid_ether_addr(ndev->dev_addr))
+		printk("%s: Invalid ethernet MAC address.  Please set using ifconfig\n", ndev->name);
+
+	if ((ret = register_netdev(ndev)) != 0) {
+		goto err_register;
+	}
+	platform_set_drvdata( pdev, ndev);
+	return 0;
+
+err_register:
+	netx_eth_disable(ndev);
+err_enable:
+	netx4000_xceth_fifo_release( priv->portno);
+err:
+	free_netdev(ndev);
+
+	return ret;
+}
+
+static int netx_eth_drv_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = dev_get_drvdata(&pdev->dev);
+
+	if (ndev != NULL) {
+		unregister_netdev(ndev);
+
+		netx_eth_disable( ndev);
+
+		free_netdev(ndev);
+	}
+	return 0;
+}
+
+static int netx_eth_drv_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	dev_err(&pdev->dev, "suspend not implemented\n");
+	return 0;
+}
+
+static int netx_eth_drv_resume(struct platform_device *pdev)
+{
+	dev_err(&pdev->dev, "resume not implemented\n");
+	return 0;
+}
+
+static struct of_device_id const netx4000_xceth_of_match[] __refconst = {
+	{ .compatible = "hilscher,netx4000-xceth", },
+	{ .compatible = "hilscher,netx4000-xceth0", },
+	{ .compatible = "hilscher,netx4000-xceth1", },
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, netx4000_xceth_of_match);
+
+static struct platform_driver netx4000_xceth_platform_driver = {
+	.probe = netx_eth_drv_probe,
+	.remove = netx_eth_drv_remove,
+	.suspend = netx_eth_drv_suspend,
+	.resume = netx_eth_drv_resume,
+	.driver = {
+		.name = "netx4000-xceth",
+		.owner = THIS_MODULE,
+		.of_match_table = netx4000_xceth_of_match,
+	},
+};
+
+struct platform_device *debug_device = NULL;
+
+static int __init netx_eth_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register( &netx4000_xceth_platform_driver);
+	printk("Registering netX4000 Ethernet driver (ret=%d)\n", ret);
+
+	return ret;
+}
+
+static void __exit netx_eth_cleanup(void)
+{
+	printk("De-registering netX4000 Ethernet driver\n");
+	platform_driver_unregister( &netx4000_xceth_platform_driver);
+}
+
+module_init(netx_eth_init);
+module_exit(netx_eth_cleanup);
+
+MODULE_SOFTDEP("pre: mdio-xc-netx4000");
+
+MODULE_AUTHOR(", hilscher");
+MODULE_LICENSE("GPL");
+MODULE_FIRMWARE("hethmac-xc0");
+MODULE_FIRMWARE("hethmac-xc1");
+MODULE_FIRMWARE("hethmac-xc2");
+MODULE_FIRMWARE("hethmac-xc3");
diff --git a/drivers/net/ethernet/netx4000/netx4000-xc-hal.c b/drivers/net/ethernet/netx4000/netx4000-xc-hal.c
new file mode 100644
index 000000000000..cfb376a45d1e
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/netx4000-xc-hal.c
@@ -0,0 +1,909 @@
+
+/* TODO: Perhaps, we could define it by yocto recipe. */
+// #define __BAREBOX_CODE 1
+
+#ifdef __BAREBOX_CODE
+// 	#warning "BAREBOX_CODE"
+	#include <common.h>
+	#include <init.h>
+
+	#include <mach/hardware.h>
+	#include "netx4000-xc-hal.h"
+	#include "netx4000-xc-main.h"
+
+	/* Remove comment tags below for using linux code */
+// 	#define request_mem_region(start,n,name)   request_iomem_region(name, start, start+n-1)
+// 	#define release_region(start,n)            release_region(start)
+// 	#define ioremap(res_cookie,size)           IOMEM(res_cookie)
+
+#else
+// 	#warning "LINUX_CODE"
+	/* Linux specific code */
+	#include <linux/slab.h>
+	#include <linux/io.h>
+	#include <linux/module.h>
+	#include <linux/init.h>
+	#include <linux/device.h>
+
+	#include "netx4000-xc-hal.h"
+
+	#define Addr_NX4000_xc_xpec_irq_registers 0xF4023A60U
+	#define HW_PTR_XPEC_IRQ_REGS(var)   static volatile uint32_t*  const var   = (volatile uint32_t*) Addr_NX4000_xc_xpec_irq_registers;
+	HW_PTR_XPEC_IRQ_REGS(s_ptXpecIrqRegs)
+
+#endif
+
+/*****************************************************************************/
+/* Definitions                                                               */
+/*****************************************************************************/
+
+#define NUM_XPECS_PER_XC 2
+#define NUM_XMACS_PER_XC 2
+
+#define NUM_XPECS 4
+#define NUM_XMACS 4
+
+#define XMAC_RPU_DWORD_RAMSIZE 0x0100
+#define XMAC_TPU_DWORD_RAMSIZE 0x0100
+#define XPEC_DWORD_RAMSIZE     0x0800
+
+/*****************************************************************************/
+/*  Variables                                                                */
+/*****************************************************************************/
+
+static const uint32_t XcCode_rpu_reset0[27] = {
+  0x00000064, /* program size */
+  0x00000000, /* trailing loads size */
+  0xf4020000, /* start address */
+  0x01300001, 0xe15bde81, 0x01380001, 0xe15bde82, 0x0143fffd, 0xe15bde83, 0x0147fffd, 0xe15bde84,
+  0x01480001, 0xe15bde85, 0x0143fff9, 0xe15bde86, 0x014bfffd, 0xe15bde87, 0x01440001, 0xe15bde88,
+  0x0143fffd, 0xe15bde89, 0x01480001, 0xe15bde8a, 0x01380005, 0xe15bde8b, 0x01080000, 0x001fde8b,
+  /* trailing loads */
+};
+
+static const uint32_t XcCode_rpu_reset1[27] = {
+  0x00000064, /* program size */
+  0x00000000, /* trailing loads size */
+  0xf4020800, /* start address */
+  0x01300001, 0xe15bde81, 0x01380001, 0xe15bde82, 0x0143fffd, 0xe15bde83, 0x0147fffd, 0xe15bde84,
+  0x01480001, 0xe15bde85, 0x0143fff9, 0xe15bde86, 0x014bfffd, 0xe15bde87, 0x01440001, 0xe15bde88,
+  0x0143fffd, 0xe15bde89, 0x01480001, 0xe15bde8a, 0x01380005, 0xe15bde8b, 0x01080000, 0x001fde8b,
+  /* trailing loads */
+};
+
+static const uint32_t XcCode_rpu_reset2[27] = {
+  0x00000064, /* program size */
+  0x00000000, /* trailing loads size */
+  0xf4021000, /* start address */
+  0x01300001, 0xe15bde81, 0x01380001, 0xe15bde82, 0x0143fffd, 0xe15bde83, 0x0147fffd, 0xe15bde84,
+  0x01480001, 0xe15bde85, 0x0143fff9, 0xe15bde86, 0x014bfffd, 0xe15bde87, 0x01440001, 0xe15bde88,
+  0x0143fffd, 0xe15bde89, 0x01480001, 0xe15bde8a, 0x01380005, 0xe15bde8b, 0x01080000, 0x001fde8b,
+  /* trailing loads */
+};
+
+static const uint32_t XcCode_rpu_reset3[27] = {
+  0x00000064, /* program size */
+  0x00000000, /* trailing loads size */
+  0xf4021800, /* start address */
+  0x01300001, 0xe15bde81, 0x01380001, 0xe15bde82, 0x0143fffd, 0xe15bde83, 0x0147fffd, 0xe15bde84,
+  0x01480001, 0xe15bde85, 0x0143fff9, 0xe15bde86, 0x014bfffd, 0xe15bde87, 0x01440001, 0xe15bde88,
+  0x0143fffd, 0xe15bde89, 0x01480001, 0xe15bde8a, 0x01380005, 0xe15bde8b, 0x01080000, 0x001fde8b,
+  /* trailing loads */
+};
+
+static const uint32_t XcCode_tpu_reset0[27] = {
+  0x00000064, /* program size */
+  0x00000000, /* trailing loads size */
+  0xf4020400, /* start address */
+  0x014c0601, 0xe15bde81, 0x01540001, 0xe15bde82, 0x015ffffd, 0xe15bde83, 0x0163fffd, 0xe15bde84,
+  0x01640001, 0xe15bde85, 0x015ffff9, 0xe15bde86, 0x0167fffd, 0xe15bde87, 0x01600001, 0xe15bde88,
+  0x015ffffd, 0xe15bde89, 0x01640001, 0xe15bde8a, 0x01540005, 0xe15bde8b, 0x01080000, 0x001fde8b,
+  /* trailing loads */
+};
+
+static const uint32_t XcCode_tpu_reset1[27] = {
+  0x00000064, /* program size */
+  0x00000000, /* trailing loads size */
+  0xf4020c00, /* start address */
+  0x014c0601, 0xe15bde81, 0x01540001, 0xe15bde82, 0x015ffffd, 0xe15bde83, 0x0163fffd, 0xe15bde84,
+  0x01640001, 0xe15bde85, 0x015ffff9, 0xe15bde86, 0x0167fffd, 0xe15bde87, 0x01600001, 0xe15bde88,
+  0x015ffffd, 0xe15bde89, 0x01640001, 0xe15bde8a, 0x01540005, 0xe15bde8b, 0x01080000, 0x001fde8b,
+  /* trailing loads */
+};
+
+static const uint32_t XcCode_tpu_reset2[27] = {
+  0x00000064, /* program size */
+  0x00000000, /* trailing loads size */
+  0xf4021400, /* start address */
+  0x014c0601, 0xe15bde81, 0x01540001, 0xe15bde82, 0x015ffffd, 0xe15bde83, 0x0163fffd, 0xe15bde84,
+  0x01640001, 0xe15bde85, 0x015ffff9, 0xe15bde86, 0x0167fffd, 0xe15bde87, 0x01600001, 0xe15bde88,
+  0x015ffffd, 0xe15bde89, 0x01640001, 0xe15bde8a, 0x01540005, 0xe15bde8b, 0x01080000, 0x001fde8b,
+  /* trailing loads */
+};
+
+static const uint32_t XcCode_tpu_reset3[27] = {
+  0x00000064, /* program size */
+  0x00000000, /* trailing loads size */
+  0xf4021c00, /* start address */
+  0x014c0601, 0xe15bde81, 0x01540001, 0xe15bde82, 0x015ffffd, 0xe15bde83, 0x0163fffd, 0xe15bde84,
+  0x01640001, 0xe15bde85, 0x015ffff9, 0xe15bde86, 0x0167fffd, 0xe15bde87, 0x01600001, 0xe15bde88,
+  0x015ffffd, 0xe15bde89, 0x01640001, 0xe15bde8a, 0x01540005, 0xe15bde8b, 0x01080000, 0x001fde8b,
+  /* trailing loads */
+};
+
+/* Use the same reset code binaries (placeholder for different reset codes) */
+#define XcCode_xc0_rpu_reset0 XcCode_rpu_reset0
+#define XcCode_xc0_rpu_reset1 XcCode_rpu_reset1
+
+#define XcCode_xc1_rpu_reset0 XcCode_rpu_reset2
+#define XcCode_xc1_rpu_reset1 XcCode_rpu_reset3
+
+#define XcCode_xc0_tpu_reset0 XcCode_tpu_reset0
+#define XcCode_xc0_tpu_reset1 XcCode_tpu_reset1
+
+#define XcCode_xc1_tpu_reset0 XcCode_tpu_reset2
+#define XcCode_xc1_tpu_reset1 XcCode_tpu_reset3
+
+static const uint32_t* paulxMacRpuCodes[4]=
+{
+  XcCode_xc0_rpu_reset0,
+  XcCode_xc0_rpu_reset1,
+  XcCode_xc1_rpu_reset0,
+  XcCode_xc1_rpu_reset1,
+};
+
+static const uint32_t* paulxMacTpuCodes[4]=
+{
+  XcCode_xc0_tpu_reset0,
+  XcCode_xc0_tpu_reset1,
+  XcCode_xc1_tpu_reset0,
+  XcCode_xc1_tpu_reset1,
+};
+
+static uint32_t refcount = 0;
+
+struct resource *startstop_res = NULL;
+struct resource *irqregs_res = NULL;
+struct resource *dpm_res = NULL;
+
+#ifdef __BAREBOX_CODE
+
+int xc_release_xc_res(struct xc_res *xcRes)
+{
+	if (xcRes->rpec_res)
+		release_region(xcRes->rpec_res);
+	if (xcRes->tpec_res)
+		release_region(xcRes->tpec_res);
+	if (xcRes->rpu_res)
+		release_region(xcRes->rpu_res);
+	if (xcRes->tpu_res)
+		release_region(xcRes->tpu_res);
+
+	if (xcRes->rpec_regs_res)
+		release_region(xcRes->rpec_regs_res);
+	if (xcRes->tpec_regs_res)
+		release_region(xcRes->tpec_regs_res);
+	if (xcRes->xmac_regs_res)
+		release_region(xcRes->xmac_regs_res);
+
+	if (--refcount == 0) {
+		if (startstop_res)
+			release_region(startstop_res);
+		if (irqregs_res)
+			release_region(irqregs_res);
+		if (dpm_res)
+			release_region(dpm_res);
+	}
+
+	kfree(xcRes);
+
+	return 0;
+}
+
+struct xc_res *xc_alloc_xc_res(struct device_d *dev, uint32_t uiPort)
+{
+	struct xc_res *xcRes;
+	struct resource *res;
+
+	xcRes = kzalloc(sizeof(*xcRes),GFP_KERNEL);
+	if (!xcRes)
+		return NULL;
+
+	do {
+		res = request_iomem_region(dev_name(dev), (resource_size_t)s_apulRpecPramArea[uiPort], (resource_size_t)s_apulRpecPramAreaEnd[uiPort]+sizeof(uint32_t)-1);
+		if (IS_ERR(res))
+			break;
+		xcRes->rpec_res = res;
+
+		res = request_iomem_region(dev_name(dev), (resource_size_t)s_apulTpecPramArea[uiPort], (resource_size_t)s_apulTpecPramAreaEnd[uiPort]+sizeof(uint32_t)-1);
+		if (IS_ERR(res))
+			break;
+		xcRes->tpec_res = res;
+
+		res = request_iomem_region(dev_name(dev), (resource_size_t)s_aptRpuPramArea[uiPort], (resource_size_t)s_aptRpuPramAreaEnd[uiPort]+sizeof(uint32_t)-1);
+		if (IS_ERR(res))
+			break;
+		xcRes->rpu_res = res;
+
+		res = request_iomem_region(dev_name(dev), (resource_size_t)s_aptTpuPramArea[uiPort], (resource_size_t)s_aptTpuPramAreaEnd[uiPort]+sizeof(uint32_t)-1);
+		if (IS_ERR(res))
+			break;
+		xcRes->tpu_res = res;
+
+		res = request_iomem_region(dev_name(dev), (resource_size_t)s_aptRpecRegArea[uiPort], (resource_size_t)(s_aptRpecRegArea[uiPort]+1)-1);
+		if (IS_ERR(res))
+			break;
+		xcRes->rpec_regs_res = res;
+
+		res = request_iomem_region(dev_name(dev), (resource_size_t)s_aptTpecRegArea[uiPort], (resource_size_t)(s_aptTpecRegArea[uiPort]+1)-1);
+		if (IS_ERR(res))
+			break;
+		xcRes->tpec_regs_res = res;
+
+		res = request_iomem_region(dev_name(dev), (resource_size_t)s_aptXmacArea[uiPort], (resource_size_t)(s_aptXmacArea[uiPort]+1)-1);
+		if (IS_ERR(res))
+			break;
+		xcRes->xmac_regs_res = res;
+
+		if (refcount++ == 0) {
+			res = request_iomem_region(dev_name(dev), (resource_size_t)s_ptXcStartStop, (resource_size_t)s_ptXcStartStop+sizeof(uint32_t)-1);
+			if (IS_ERR(res))
+				break;
+			startstop_res = res;
+
+			//TODO:
+			res = request_iomem_region(dev_name(dev), (resource_size_t)s_ptXpecIrqRegs, (resource_size_t)s_ptXpecIrqRegs+sizeof(uint32_t)-1);
+			//if (IS_ERR(res))
+			//	break;
+			//irqregs_res = res;
+
+//FIXME 			res = request_iomem_region(dev_name(dev), start, end);
+// 			if (IS_ERR(res))
+// 				break;
+// 			dpm_res = res;
+		}
+		xcRes->startstop_res = startstop_res;
+		xcRes->irqregs_res = irqregs_res;
+		xcRes->dpm_res = dpm_res;
+	} while (0);
+
+	if (IS_ERR(res))
+		goto err_out;
+
+	printk("%s: refcount = %i\n", __func__, refcount);
+
+	xcRes->xcinst = uiPort;
+
+	xcRes->rpec_pram_area = IOMEM(xcRes->rpec_res->start);
+	xcRes->tpec_pram_area = IOMEM(xcRes->tpec_res->start);
+	xcRes->rpu_pram_area = IOMEM(xcRes->rpu_res->start);
+	xcRes->tpu_pram_area = IOMEM(xcRes->tpu_res->start);
+
+	xcRes->rpec_reg_area = IOMEM(xcRes->rpec_regs_res->start);
+	xcRes->tpec_reg_area = IOMEM(xcRes->tpec_regs_res->start);
+	xcRes->xmac_area = IOMEM(xcRes->xmac_regs_res->start);
+
+	xcRes->xc_startstop = IOMEM(xcRes->startstop_res->start);
+	xcRes->xpec_irqregs = IOMEM(xcRes->irqregs_res->start);
+//FIXME 	xcRes->xpec_dpm = IOMEM(xcRes->dpm_res->start);
+
+	return xcRes;
+
+err_out:
+	xc_release_xc_res(xcRes);
+
+	return NULL;
+}
+
+#else /* __BAREBOX_CODE */
+
+int xc_release_xc_res(struct xc_res *xcRes)
+{
+	if (xcRes->rpec_res)
+		release_mem_region(xcRes->rpec_res->start, resource_size(xcRes->rpec_res));
+	if (xcRes->tpec_res)
+		release_mem_region(xcRes->tpec_res->start, resource_size(xcRes->tpec_res));
+	if (xcRes->rpu_res)
+		release_mem_region(xcRes->rpu_res->start, resource_size(xcRes->rpu_res));
+	if (xcRes->tpu_res)
+		release_mem_region(xcRes->tpu_res->start, resource_size(xcRes->tpu_res));
+
+	if (xcRes->rpec_regs_res)
+		release_mem_region(xcRes->rpec_regs_res->start, resource_size(xcRes->rpec_regs_res));
+	if (xcRes->tpec_regs_res)
+		release_mem_region(xcRes->tpec_regs_res->start, resource_size(xcRes->tpec_regs_res));
+	if (xcRes->xmac_regs_res)
+		release_mem_region(xcRes->xmac_regs_res->start, resource_size(xcRes->xmac_regs_res));
+
+	if (--refcount == 0) {
+		if (startstop_res)
+			release_mem_region(startstop_res->start, resource_size(startstop_res));
+		if (irqregs_res)
+			release_mem_region(irqregs_res->start, resource_size(irqregs_res));
+		if (dpm_res)
+			release_mem_region(dpm_res->start, resource_size(dpm_res));
+	}
+
+	kfree(xcRes);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xc_release_xc_res);
+
+struct xc_res *xc_alloc_xc_res(struct device *dev, uint32_t uiPort)
+{
+	struct xc_res *xcRes;
+	struct resource *res;
+
+	xcRes = kzalloc(sizeof(*xcRes), GFP_KERNEL);
+	if (!xcRes)
+		return NULL;
+
+	do {
+		res = request_mem_region((resource_size_t)s_apulRpecPramArea[uiPort], (resource_size_t)s_apulRpecPramAreaEnd[uiPort]-(resource_size_t)s_apulRpecPramArea[uiPort]+sizeof(uint32_t), dev_name(dev));
+		if (IS_ERR(res))
+			break;
+		xcRes->rpec_res = res;
+
+		res = request_mem_region((resource_size_t)s_apulTpecPramArea[uiPort], (resource_size_t)s_apulTpecPramAreaEnd[uiPort]-(resource_size_t)s_apulTpecPramArea[uiPort]+sizeof(uint32_t), dev_name(dev));
+		if (IS_ERR(res))
+			break;
+		xcRes->tpec_res = res;
+
+		res = request_mem_region((resource_size_t)s_aptRpuPramArea[uiPort], (resource_size_t)s_aptRpuPramAreaEnd[uiPort]-(resource_size_t)s_aptRpuPramArea[uiPort]+sizeof(uint32_t), dev_name(dev));
+		if (IS_ERR(res))
+			break;
+		xcRes->rpu_res = res;
+
+		res = request_mem_region((resource_size_t)s_aptTpuPramArea[uiPort], (resource_size_t)s_aptTpuPramAreaEnd[uiPort]-(resource_size_t)s_aptTpuPramArea[uiPort]+sizeof(uint32_t), dev_name(dev));
+		if (IS_ERR(res))
+			break;
+		xcRes->tpu_res = res;
+
+		res = request_mem_region((resource_size_t)s_aptRpecRegArea[uiPort], (resource_size_t)sizeof(*s_aptRpecRegArea[uiPort]), dev_name(dev));
+		if (IS_ERR(res))
+			break;
+		xcRes->rpec_regs_res = res;
+
+		res = request_mem_region((resource_size_t)s_aptTpecRegArea[uiPort], (resource_size_t)sizeof(*s_aptTpecRegArea[uiPort]), dev_name(dev));
+		if (IS_ERR(res))
+			break;
+		xcRes->tpec_regs_res = res;
+
+		res = request_mem_region((resource_size_t)s_aptXmacArea[uiPort], (resource_size_t)sizeof(*s_aptXmacArea[uiPort]), dev_name(dev));
+		if (IS_ERR(res))
+			break;
+		xcRes->xmac_regs_res = res;
+
+		if (refcount++ == 0) {
+			res = request_mem_region((resource_size_t)s_ptXcStartStop, (resource_size_t)sizeof(*s_ptXcStartStop), dev_name(dev));
+			if (IS_ERR(res))
+				break;
+			startstop_res = res;
+
+			//TODO:
+			//res = request_mem_region((resource_size_t)s_ptXpecIrqRegs, (resource_size_t)sizeof(*s_ptXpecIrqRegs), dev_name(dev));
+			//if (IS_ERR(res))
+			//	break;
+			//irqregs_res = res;
+
+//FIXME 			res = request_mem_region(start, n, dev_name(dev));
+// 			if (IS_ERR(res))
+// 				break;
+// 			dpm_res = res;
+		}
+		xcRes->startstop_res = startstop_res;
+		//xcRes->irqregs_res = irqregs_res;
+		xcRes->dpm_res = dpm_res;
+	} while (0);
+
+	if (IS_ERR(res))
+		goto err_out;
+
+	xcRes->xcinst = uiPort;
+
+	xcRes->rpec_pram_area = ioremap(xcRes->rpec_res->start, resource_size(xcRes->rpec_res));
+	xcRes->tpec_pram_area = ioremap(xcRes->tpec_res->start, resource_size(xcRes->tpec_res));
+	xcRes->rpu_pram_area = ioremap(xcRes->rpu_res->start, resource_size(xcRes->rpu_res));
+	xcRes->tpu_pram_area = ioremap(xcRes->tpu_res->start, resource_size(xcRes->tpu_res));
+
+	xcRes->rpec_reg_area = ioremap(xcRes->rpec_regs_res->start, resource_size(xcRes->rpec_regs_res));
+	xcRes->tpec_reg_area = ioremap(xcRes->tpec_regs_res->start, resource_size(xcRes->tpec_regs_res));
+	xcRes->xmac_area = ioremap(xcRes->xmac_regs_res->start, resource_size(xcRes->xmac_regs_res));
+
+	xcRes->xc_startstop = ioremap(xcRes->startstop_res->start, resource_size(xcRes->startstop_res));
+	//xcRes->xpec_irqregs = ioremap(xcRes->irqregs_res->start, resource_size(xcRes->irqregs_res));
+//FIXME 	xcRes->xpec_dpm = ioremap(xcRes->dpm_res->start, resource_size(xcRes->dpm_res));
+
+	return xcRes;
+
+err_out:
+	xc_release_xc_res(xcRes);
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(xc_alloc_xc_res);
+
+#endif /* __BAREBOX_CODE */
+
+
+/*****************************************************************************/
+/*! Reset XC Code
+* \description
+*   Reset XC port.
+* \class
+*   XC
+* \params
+*   port          [in]  XC Port Number
+*   pvUser           [in]  User Specific Paramters
+* \return
+*   0 on success
+*   -1 on erroneous                                                          */
+/*****************************************************************************/
+int __xc_reset(struct xc_res* xc)
+{
+  NX4000_XMAC_AREA_T* ptXmac;
+  NX4000_XPEC_AREA_T* ptRpec;
+  NX4000_XPEC_AREA_T* ptTpec;
+  volatile uint32_t* pulRpecPram;
+  volatile uint32_t* pulTpecPram;
+  unsigned int uIdx;
+
+  if(xc->xcinst >= NUM_XPECS)
+	return -1;
+
+  ptXmac      = xc->xmac_area;
+  ptRpec      = xc->rpec_reg_area;
+  ptTpec      = xc->tpec_reg_area;
+  pulRpecPram = xc->rpec_pram_area;
+  pulTpecPram = xc->tpec_pram_area;
+
+  /* Stop xPEC and xMAC */
+  xc->xc_startstop->ulXc_start_stop_ctrl = ( HW_MSK(xc_start_stop_ctrl_xc0_stop_rpec0) |
+                                            HW_MSK(xc_start_stop_ctrl_xc0_stop_tpec0) |
+                                            HW_MSK(xc_start_stop_ctrl_xc0_stop_rpu0)  |
+                                            HW_MSK(xc_start_stop_ctrl_xc0_stop_tpu0)
+                                           ) << (4 * xc->xcinst);
+
+  /* Clear output enable of tx asap */
+  ptXmac->ulXmac_config_obu  = HW_DFLT_VAL(xmac_config_obu);
+
+  /* reset mii_txd_oe_next to avoid MII.TXEN spike (config_mii[2] = 1 resets internal OBU signal mii_txd_oe_nxt) */
+  ptXmac->ulXmac_config_mii  = HW_DFLT_VAL(xmac_config_mii) | (1U << 2);
+
+  /* Clear output enable of io0..5 asap */
+  ptRpec->aulStatcfg[xc->portno] = 0xffff0000;
+
+  switch( xc->portno )
+  {
+    case 0: ptRpec->ulXpec_config = HW_MSK(xpec_config_reset_urx_fifo0) | HW_MSK(xpec_config_reset_utx_fifo0);
+            break;
+    case 1: ptRpec->ulXpec_config = HW_MSK(xpec_config_reset_urx_fifo1) | HW_MSK(xpec_config_reset_utx_fifo1);
+            break;
+  }
+
+  /* load rate multiplier reset code */
+  if( xc_load( xc, XC_TYPE_RPU, paulxMacRpuCodes[xc->xcinst]) != 0) {
+    return -2;
+  }
+  if( xc_load( xc, XC_TYPE_TPU, paulxMacTpuCodes[xc->xcinst]) != 0) {
+    return -3;
+  }
+
+  ptXmac->ulXmac_rpu_pc      = 0; /* Reset PC to 0 */
+  ptXmac->ulXmac_tpu_pc      = 0; /* Reset PC to 0 */
+
+  xc->xc_startstop->ulXc_start_stop_ctrl = (HW_MSK(xc_start_stop_ctrl_xc0_start_rpu0) |
+                                           HW_MSK(xc_start_stop_ctrl_xc0_start_tpu0)) << (4 * xc->xcinst);
+
+  /* !!!! ATTENTION: There must be enough time between starting xMAC and stopping xMAC to execute reset program */
+
+  pulRpecPram[0] = 0xC0000FFF;                                   /* Use the command wait b000000000000,b111111111111 at Address 0*/
+  pulTpecPram[0] = 0xC0000FFF;                                   /* Use the command wait b000000000000,b111111111111 at Address 0*/
+
+  ptRpec->ulXpec_pc = 0x7ff;                                     /* Reset the Program Counter to 0x7ff */
+  ptTpec->ulXpec_pc = 0x7ff;                                     /* Reset the Program Counter to 0x7ff */
+
+
+  /* let the XC run for at least 10 cycles */
+  for (uIdx = 0; uIdx < 10; uIdx++)
+  {
+    xc->xc_startstop->ulXc_start_stop_ctrl = (HW_MSK(xc_start_stop_ctrl_xc0_start_rpec0) |
+                                             HW_MSK(xc_start_stop_ctrl_xc0_start_tpec0)) << (4 * xc->xcinst);
+  }
+
+  xc->xc_startstop->ulXc_start_stop_ctrl = (HW_MSK(xc_start_stop_ctrl_xc0_stop_rpec0) |
+                                           HW_MSK(xc_start_stop_ctrl_xc0_stop_tpec0)) << (4 * xc->xcinst);
+  ptRpec->ulXpec_pc     = 0x7ff;                                 /* Reset the Program Counter to 0x7ff */
+  ptTpec->ulXpec_pc     = 0x7ff;                                 /* Reset the Program Counter to 0x7ff */
+
+  /* reset all registers */
+  ptRpec->aulXpec_r[0]   = 0;
+  ptTpec->aulXpec_r[0]   = 0;
+  ptRpec->aulXpec_r[1]   = 0;
+  ptTpec->aulXpec_r[1]   = 0;
+  ptRpec->aulXpec_r[2]   = 0;
+  ptTpec->aulXpec_r[2]   = 0;
+  ptRpec->aulXpec_r[3]   = 0;
+  ptTpec->aulXpec_r[3]   = 0;
+  ptRpec->aulXpec_r[4]   = 0;
+  ptTpec->aulXpec_r[4]   = 0;
+  ptRpec->aulXpec_r[5]   = 0;
+  ptTpec->aulXpec_r[5]   = 0;
+  ptRpec->aulXpec_r[6]   = 0;
+  ptTpec->aulXpec_r[6]   = 0;
+  ptRpec->aulXpec_r[7]   = 0;
+  ptTpec->aulXpec_r[7]   = 0;
+
+  /* Note regarding stat_bits_shared: this register is used for XC instance crossover protocols, protocol has to clear this register when initializing */
+
+  ptRpec->ulRange_urtx_count = 0;
+  ptTpec->ulRange_urtx_count = 0;
+  ptRpec->ulRange45          = 0;
+  ptTpec->ulRange45          = 0;
+  ptRpec->ulRange67          = 0;
+  ptTpec->ulRange67          = 0;
+  ptRpec->ulUrx_count        = 0;
+  ptTpec->ulUrx_count        = 0;
+  ptRpec->ulUtx_count        = 0;
+  ptTpec->ulUtx_count        = 0;
+
+  /* Stop all Timers */
+  ptRpec->ulTimer4       = 0;
+  ptTpec->ulTimer4       = 0;
+  ptRpec->ulTimer5       = 0;
+  ptTpec->ulTimer5       = 0;
+  ptRpec->aulTimer[0]    = 0;
+  ptTpec->aulTimer[0]    = 0;
+  ptRpec->aulTimer[1]    = 0;
+  ptTpec->aulTimer[1]    = 0;
+  ptRpec->aulTimer[2]    = 0;
+  ptTpec->aulTimer[2]    = 0;
+  ptRpec->aulTimer[3]    = 0;
+  ptTpec->aulTimer[3]    = 0;
+
+  ptRpec->ulIrq          = 0xFFFF0000; /* Clear XPEC side IRQ request lines */
+  ptTpec->ulIrq          = 0xFFFF0000; /* Clear XPEC side IRQ request lines */
+
+  /* Reset events */
+  ptRpec->ulEc_maska     = 0x0000FFFF;
+  ptTpec->ulEc_maska     = 0x0000FFFF;
+  ptRpec->ulEc_maskb     = 0x0000FFFF;
+  ptTpec->ulEc_maskb     = 0x0000FFFF;
+  ptRpec->aulEc_mask[0]  = 0x0000FFFF;
+  ptTpec->aulEc_mask[0]  = 0x0000FFFF;
+  ptRpec->aulEc_mask[1]  = 0x0000FFFF;
+  ptTpec->aulEc_mask[1]  = 0x0000FFFF;
+  ptRpec->aulEc_mask[2]  = 0x0000FFFF;
+  ptTpec->aulEc_mask[2]  = 0x0000FFFF;
+  ptRpec->aulEc_mask[3]  = 0x0000FFFF;
+  ptTpec->aulEc_mask[3]  = 0x0000FFFF;
+  ptRpec->aulEc_mask[4]  = 0x0000FFFF;
+  ptTpec->aulEc_mask[4]  = 0x0000FFFF;
+  ptRpec->aulEc_mask[5]  = 0x0000FFFF;
+  ptTpec->aulEc_mask[5]  = 0x0000FFFF;
+  ptRpec->aulEc_mask[6]  = 0x0000FFFF;
+  ptTpec->aulEc_mask[6]  = 0x0000FFFF;
+  ptRpec->aulEc_mask[7]  = 0x0000FFFF;
+  ptTpec->aulEc_mask[7]  = 0x0000FFFF;
+  ptRpec->aulEc_mask[8]  = 0x0000FFFF;
+  ptTpec->aulEc_mask[8]  = 0x0000FFFF;
+  ptRpec->aulEc_mask[9]  = 0x0000FFFF;
+  ptTpec->aulEc_mask[9]  = 0x0000FFFF;
+
+  /* Reset shared registers */
+  /* Reset SR0-3 for XPEC0, SR4-7 for XPEC1 */
+  for( uIdx = (4 * xc->portno); uIdx < (4 * xc->portno + 4); ++uIdx )
+    ptRpec->aulXpec_sr[uIdx] = 0;
+  /* Reset SR8-11 for XPEC0, SR12-15 for XPEC1 */
+  for( uIdx = (8 + 4 * xc->portno); (uIdx < 12 + 4 * xc->portno); ++uIdx )
+    ptRpec->aulXpec_sr[uIdx] = 0;
+
+  ptRpec->ulDatach_wr_cfg = 0;
+  ptTpec->ulDatach_wr_cfg = 0;
+  ptRpec->ulDatach_rd_cfg = 0;
+  ptTpec->ulDatach_rd_cfg = 0;
+  ptRpec->ulSysch_addr    = 0;
+  ptTpec->ulSysch_addr    = 0;
+
+  /* confirm all interrupts from xPEC -> Select the specific XC instance and get IRQ */
+   *xc->xpec_irqregs = 0x0000FFFF;
+  //*xc->xpec_irqregs = 0x0000FFFF;
+
+  /* hold xMAC */
+  xc->xc_startstop->ulXc_start_stop_ctrl = (HW_MSK(xc_start_stop_ctrl_xc0_stop_rpu0) |
+                                           HW_MSK(xc_start_stop_ctrl_xc0_stop_tpu0)) << (4 * xc->xcinst);
+
+  /* reset all xMAC registers to default values */
+  ptXmac->ulXmac_rx_hw               = 0;
+  ptXmac->ulXmac_rx_hw_count         = 0;
+  ptXmac->ulXmac_tx                  = 0;
+  ptXmac->ulXmac_tx_hw               = 0;
+  ptXmac->ulXmac_tx_hw_count         = 0;
+  ptXmac->ulXmac_tx_sent             = 0;
+  ptXmac->aulXmac_wr[0]              = 0;
+  ptXmac->aulXmac_wr[1]              = 0;
+  ptXmac->aulXmac_wr[2]              = 0;
+  ptXmac->aulXmac_wr[3]              = 0;
+  ptXmac->aulXmac_wr[4]              = 0;
+  ptXmac->aulXmac_wr[5]              = 0;
+  ptXmac->aulXmac_wr[6]              = 0;
+  ptXmac->aulXmac_wr[7]              = 0;
+  ptXmac->aulXmac_wr[8]              = 0;
+  ptXmac->aulXmac_wr[9]              = 0;
+  ptXmac->ulXmac_config_mii          = 0;
+  ptXmac->ulXmac_config_rx_nibble_fifo  = HW_DFLT_VAL(xmac_config_rx_nibble_fifo);
+  ptXmac->ulXmac_config_tx_nibble_fifo  = 0;
+  ptXmac->ulXmac_rpu_count1          = 0;
+  ptXmac->ulXmac_rpu_count2          = 0;
+  ptXmac->ulXmac_tpu_count1          = 0;
+  ptXmac->ulXmac_tpu_count2          = 0;
+  ptXmac->ulXmac_rx_count            = 0;
+  ptXmac->ulXmac_tx_count            = 0;
+  ptXmac->ulXmac_rpm_mask0           = 0;
+  ptXmac->ulXmac_rpm_val0            = 0;
+  ptXmac->ulXmac_rpm_mask1           = 0;
+  ptXmac->ulXmac_rpm_val1            = 0;
+  ptXmac->ulXmac_tpm_mask0           = 0;
+  ptXmac->ulXmac_tpm_val0            = 0;
+  ptXmac->ulXmac_tpm_mask1           = 0;
+  ptXmac->ulXmac_tpm_val1            = 0;
+
+  ptXmac->ulXmac_rx_crc_polynomial_l = 0;
+  ptXmac->ulXmac_rx_crc_polynomial_h = 0;
+  ptXmac->ulXmac_rx_crc_l            = 0;
+  ptXmac->ulXmac_rx_crc_h            = 0;
+  ptXmac->ulXmac_rx_crc_cfg          = 0;
+  ptXmac->ulXmac_tx_crc_polynomial_l = 0;
+  ptXmac->ulXmac_tx_crc_polynomial_h = 0;
+  ptXmac->ulXmac_tx_crc_l            = 0;
+  ptXmac->ulXmac_tx_crc_h            = 0;
+  ptXmac->ulXmac_tx_crc_cfg          = 0;
+
+  ptXmac->ulXmac_rx_crc32_l          = 0;
+  ptXmac->ulXmac_rx_crc32_h          = 0;
+  ptXmac->ulXmac_rx_crc32_cfg        = 0;
+  ptXmac->ulXmac_tx_crc32_l          = 0;
+  ptXmac->ulXmac_tx_crc32_h          = 0;
+  ptXmac->ulXmac_tx_crc32_cfg        = 0;
+
+  ptXmac->ulXmac_config_sbu2         = HW_DFLT_VAL(xmac_config_sbu2);
+  ptXmac->ulXmac_config_obu2         = HW_DFLT_VAL(xmac_config_obu2);
+
+  ptXmac->ulXmac_rpu_pc              = 0;
+  ptXmac->ulXmac_tpu_pc              = 0;
+
+  return 0;
+}
+
+#ifdef __BAREBOX_CODE
+
+int xc_reset(struct xc_res* xc)
+{
+    struct resource *res;
+    int rc;
+
+    res = request_iomem_region("netx4000-xc-hal-reset", (resource_size_t)s_ptXpecIrqRegs, (resource_size_t)sizeof(s_ptXpecIrqRegs));
+    if (IS_ERR(res))
+	return -EBUSY;
+    xc->irq_reg_res = res;
+    xc->irq_reg_area = IOMEM(xc->irq_reg_res->start);
+
+    rc = __xc_reset(xc);
+
+    release_region(xc->irq_reg_res);
+    xc->irq_reg_res = NULL;
+    xc->irq_reg_area = 0;
+
+    return rc;
+}
+
+#else /* __BAREBOX_CODE */
+
+int xc_reset(struct xc_res* xc)
+{
+    struct resource *res;
+    int rc;
+
+    res = request_mem_region((resource_size_t)(uint32_t)s_ptXpecIrqRegs + xc->xcinst*(sizeof(uint32_t)), sizeof(uint32_t), "netx4000-xc-hal-reset");
+    if (res == NULL)
+	return -EBUSY;
+    xc->irqregs_res = res;
+    xc->xpec_irqregs = ioremap(xc->irqregs_res->start, sizeof(uint32_t));
+
+    rc = __xc_reset(xc);
+
+    iounmap(xc->xpec_irqregs);
+
+    release_mem_region(xc->irqregs_res->start, resource_size(xc->irqregs_res));
+    xc->irqregs_res = NULL;
+    xc->xpec_irqregs = 0;
+
+    return rc;
+}
+EXPORT_SYMBOL_GPL(xc_reset);
+
+#endif /* __BAREBOX_CODE */
+
+
+
+/*****************************************************************************/
+/*! Load XC Code
+* \description
+*   Load XC port.
+* \class
+*   XC
+* \params
+*   port              [in]  XC Port Number
+*   eXcType              [in]  XC Entity To Download To (RPU, TPU, xPEC)
+*   pulXcPrg             [in]  Pointer To Microcode
+*   pvUser               [in]  User specific parameter
+* \return
+*   0 on success
+*   -1 on erroneous                                                          */
+/*****************************************************************************/
+int xc_load(struct xc_res* xc, XC_TYPE_E eXcType, const uint32_t* pulXcPrg)
+{
+  volatile uint32_t *pulDst, *pulDstCnt;
+  volatile uint32_t *pulRamStart, *pulRamEnd;
+  uint32_t ram_area = 0;
+  const uint32_t *pulSrcStart, *pulSrcCnt, *pulSrcEnd;
+  unsigned int uiElements;
+
+  /* check the instance number */
+  if(xc->xcinst >= NUM_XPECS)
+	return 1;
+
+  /* get the start and end address of the ram area, get the physical address */
+  switch( eXcType )
+  {
+    case XC_TYPE_RPEC: pulRamStart     = (volatile uint32_t*)xc->rpec_pram_area;
+                       pulRamEnd       = (volatile uint32_t*)((uint32_t)xc->rpec_pram_area + xc->rpec_res->end - xc->rpec_res->start);
+			ram_area = xc->rpec_res->start;
+                       break;
+    case XC_TYPE_TPEC: pulRamStart     = (volatile uint32_t*)xc->tpec_pram_area;
+                       pulRamEnd       = (volatile uint32_t*)((uint32_t)xc->tpec_pram_area + xc->tpec_res->end - xc->tpec_res->start);//xc->tpec_res->end;
+			ram_area = xc->tpec_res->start;//xc->tpec_pram_area;
+                       break;
+    case XC_TYPE_RPU:  pulRamStart     = (volatile uint32_t*)xc->rpu_pram_area;
+                       pulRamEnd       = (volatile uint32_t*)((uint32_t)xc->rpu_pram_area + xc->rpu_res->end - xc->rpu_res->start);//xc->rpu_res->end;
+			ram_area = xc->rpu_res->start;//xc->rpu_pram_area;
+                       break;
+    case XC_TYPE_TPU:  pulRamStart     = (volatile uint32_t*)xc->tpu_pram_area;
+                       pulRamEnd       = (volatile uint32_t*)((uint32_t)xc->tpu_pram_area + xc->tpu_res->end - xc->tpu_res->start);//xc->tpu_res->end;
+			ram_area = xc->tpu_res->start;//xc->tpu_pram_area;
+                       break;
+
+    default:           return 2; /* unknown unit type */
+  }
+
+  /* get the number of code elements */
+  uiElements = pulXcPrg[0] / sizeof(uint32_t) - 1;
+
+  /* get the pointer in the xc area */
+  /* ram_virtual_start + code_physical_start - ram_physical_start */
+  pulDst = (volatile uint32_t*) ((uint32_t)pulRamStart + pulXcPrg[2] - ram_area);
+
+  /* the code must fit into the ram area */
+  if( (pulDst<pulRamStart) || ((pulDst+uiElements)>pulRamEnd) ) {
+    /* the code exceeds the program ram! */
+    return 3;
+  }
+
+  /* Map to virtual memory */
+  //pulDst = phys_to_virt((phys_addr_t)pulDst);
+
+  /* get source start and end pointer */
+  pulSrcStart = pulXcPrg + 3;
+  pulSrcEnd = pulSrcStart + uiElements;
+
+  /* copy the code to xc ram */
+  pulSrcCnt = pulSrcStart;
+  pulDstCnt = pulDst;
+  while( pulSrcCnt<pulSrcEnd ) {
+    //TODO: get offset for virt addr
+    //printk("write to %p\n", pulDstCnt);
+
+    *pulDstCnt = *pulSrcCnt;
+    pulDstCnt++;
+    pulSrcCnt++;
+  }
+
+#ifndef XC_LOAD_NO_COMPARE
+  /* compare the code */
+  pulSrcCnt = pulSrcStart;
+  pulDstCnt = pulDst;
+  while( pulSrcCnt<pulSrcEnd ) {
+    if( *pulDstCnt != *pulSrcCnt )
+    {
+      return 4;
+    }
+    pulDstCnt++;
+    pulSrcCnt++;
+  }
+#endif
+
+  /* get the number of trailing loads */
+  uiElements = pulXcPrg[1] / sizeof(uint32_t);
+
+  /* get source start and end pointer */
+  pulSrcCnt = pulXcPrg + 2 + (pulXcPrg[0] / sizeof(uint32_t));
+  pulSrcEnd = pulSrcCnt + uiElements;
+
+  //TODO: we need to work with offsets here (so we can write to ramarea+offset) - the code contains absolute addresses
+  /* write all trailing loads */
+  while( pulSrcCnt<pulSrcEnd ) {
+    /* get the destination address ( ram_virtual_start + data_physical_start - ram_physical_start) */
+    //pulDst = (volatile uint32_t*) ((uint32_t)pulRamStart + *pulSrcCnt - ram_area);
+    pulDst = ioremap(*pulSrcCnt,sizeof(uint32_t));
+
+    /* Map to virtual memory */
+    //pulDst = phys_to_virt((phys_addr_t)pulDst);
+    pulSrcCnt++;
+
+    /* write the data */
+    *pulDst = *pulSrcCnt;
+	iounmap(pulDst);
+    pulSrcCnt++;
+  }
+
+  return 0;
+}
+EXPORT_SYMBOL_GPL(xc_load);
+
+/*****************************************************************************/
+/*! Start XC Port
+* \description
+*   Start XC port.
+* \class
+*   XC
+* \params
+*   port              [in]  XC Port Number
+*   pvUser               [in]  User specific parameter
+* \return
+*   0 on success
+*   -1 on erroneous                                                          */
+/*****************************************************************************/
+int xc_start(struct xc_res* xc)
+{
+	/* reset pc of units */
+	xc->xmac_area->ulXmac_rpu_pc = 0;
+	xc->xmac_area->ulXmac_tpu_pc = 0;
+	xc->rpec_reg_area->ulXpec_pc = 0x7ff;
+	xc->tpec_reg_area->ulXpec_pc = 0x7ff;
+
+	/* start units */
+	xc->xc_startstop->ulXc_start_stop_ctrl = ( (HW_MSK(xc_start_stop_ctrl_xc0_start_rpec0) |
+                                             HW_MSK(xc_start_stop_ctrl_xc0_start_tpec0)  |
+                                             HW_MSK(xc_start_stop_ctrl_xc0_start_rpu0)   |
+                                             HW_MSK(xc_start_stop_ctrl_xc0_start_tpu0)
+                                           ) << (4 * xc->xcinst));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xc_start);
+
+/*****************************************************************************/
+/*! Stop XC Port
+* \description
+*   Stop XC port.
+* \class
+*   XC
+* \params
+*   port              [in]  XC Port Number
+*   pvUser               [in]  User specific parameter
+* \return
+*   0 on success
+*   -1 on erroneous                                                          */
+/*****************************************************************************/
+int xc_stop(struct xc_res* xc)
+{
+	/* stop units */
+	xc->xc_startstop->ulXc_start_stop_ctrl = ( (HW_MSK(xc_start_stop_ctrl_xc0_stop_rpec0) |
+                                             HW_MSK(xc_start_stop_ctrl_xc0_stop_tpec0) |
+                                             HW_MSK(xc_start_stop_ctrl_xc0_stop_rpu0)  |
+                                             HW_MSK(xc_start_stop_ctrl_xc0_stop_tpu0)
+                                            ) << (4 * xc->xcinst));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xc_stop);
diff --git a/drivers/net/ethernet/netx4000/netx4000-xc-hal.h b/drivers/net/ethernet/netx4000/netx4000-xc-hal.h
new file mode 100644
index 000000000000..9c7b17cf323e
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/netx4000-xc-hal.h
@@ -0,0 +1,78 @@
+#ifndef __NETX4000_XC_HAL_H
+#define __NETX4000_XC_HAL_H
+
+#ifdef __BAREBOX_CODE
+	/* Barebox specific code */
+#else
+	/* Linux specific code */
+	#include <linux/ioport.h>
+	#include "netx4000-xc-res.h"
+#endif
+
+#define _HW_CONCAT(a,b) a ## b
+
+#define HW_MSK(bf)           _HW_CONCAT(MSK_NX4000_, bf)
+#define HW_DFLT_VAL(reg)     _HW_CONCAT(DFLT_VAL_NX4000_, reg)
+
+typedef enum {
+	XC_TYPE_RPEC = 0,
+	XC_TYPE_TPEC,
+	XC_TYPE_RPU,
+	XC_TYPE_TPU
+} XC_TYPE_E;
+
+typedef struct NX4000_XPEC_IRQ_REGS_Ttag
+{
+	  volatile uint32_t aulIrq_xpec[4];
+} NX4000_XPEC_IRQ_REGS_T;
+
+struct xc_res {
+	uint8_t xcinst;
+	uint8_t portno;
+
+	struct resource *rpec_res;
+	struct resource *tpec_res;
+	struct resource *rpu_res;
+	struct resource *tpu_res;
+
+	struct resource *rpec_regs_res;
+	struct resource *tpec_regs_res;
+	struct resource *xmac_regs_res;
+
+	struct resource *startstop_res;
+	struct resource *irqregs_res;
+	struct resource *dpm_res;
+
+	ETHMAC_XPEC_DPM* __iomem xpec_dpm;
+
+	void* __iomem        rpec_pram_area;
+	void* __iomem        tpec_pram_area;
+	void* __iomem rpu_pram_area;
+	void* __iomem tpu_pram_area;
+
+	NX4000_XPEC_AREA_T* __iomem rpec_reg_area;
+	NX4000_XPEC_AREA_T* __iomem tpec_reg_area;
+	NX4000_XMAC_AREA_T* __iomem xmac_area;
+
+	NX4000_XC_START_STOP_AREA_T* __iomem xc_startstop;
+	uint32_t* __iomem      xpec_irqregs;
+	//FIXME 	ETHMAC_XPEC_DPM* __iomem xpec_dpm;
+};
+
+int xc_release_xc_res(struct xc_res *xcRes);
+int xc_reset(struct xc_res* xc);
+int xc_load( struct xc_res* x, XC_TYPE_E eXcType, const uint32_t* pulXcPrg);
+int xc_start(struct xc_res* xc);
+int xc_stop(struct xc_res* xc);
+
+#ifdef __BAREBOX_CODE
+	/* Barebox specific code */
+	struct xc_res *xc_alloc_xc_res(struct device_d *dev, uint32_t uiPort);
+#else
+	struct xc_res *xc_alloc_xc_res(struct device *dev, uint32_t uiPort);
+#endif
+
+#endif
+
+
+
diff --git a/drivers/net/ethernet/netx4000/netx4000-xc-res.h b/drivers/net/ethernet/netx4000/netx4000-xc-res.h
new file mode 100644
index 000000000000..69328619d775
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/netx4000-xc-res.h
@@ -0,0 +1,811 @@
+
+#ifndef NETX4000_XC_RES_H
+#define NETX4000_XC_RES_H
+
+#include "ethmac_xpec_regdef.h"
+
+/* ===================================================================== */
+
+/* AREA xmac */
+/* Area of xc0_xmac0_regs, xc0_xmac1_regs, xc1_xmac0_regs, xc1_xmac1_regs */
+
+/* ===================================================================== */
+
+#define Addr_NX4000_xc0_xmac0_regs 0xF4022800U
+#define NX4000_NETX_XC0_XM0_BASE   0xF4022800U
+#define Addr_NX4000_xc0_xmac1_regs 0xF4022A00U
+#define NX4000_NETX_XC0_XM1_BASE   0xF4022A00U
+#define Addr_NX4000_xc1_xmac0_regs 0xF4022C00U
+#define NX4000_NETX_XC1_XM0_BASE   0xF4022C00U
+#define Addr_NX4000_xc1_xmac1_regs 0xF4022E00U
+#define NX4000_NETX_XC1_XM1_BASE   0xF4022E00U
+
+
+/* ===================================================================== */
+
+/* AREA xpec */
+/* Area of xc0_rpec0_regs, xc0_tpec0_regs, xc0_rpec1_regs, xc0_tpec1_regs, xc1_rpec0_regs, xc1_tpec0_regs, xc1_rpec1_regs, xc1_tpec1_regs */
+
+/* ===================================================================== */
+
+#define Addr_NX4000_xc0_rpec0_regs 0xF4022000U
+#define NX4000_NETX_XC0_XRP0_BASE  0xF4022000U
+#define Addr_NX4000_xc0_tpec0_regs 0xF4022100U
+#define NX4000_NETX_XC0_XTP0_BASE  0xF4022100U
+#define Addr_NX4000_xc0_rpec1_regs 0xF4022200U
+#define NX4000_NETX_XC0_XRP1_BASE  0xF4022200U
+#define Addr_NX4000_xc0_tpec1_regs 0xF4022300U
+#define NX4000_NETX_XC0_XTP1_BASE  0xF4022300U
+#define Addr_NX4000_xc1_rpec0_regs 0xF4022400U
+#define NX4000_NETX_XC1_XRP0_BASE  0xF4022400U
+#define Addr_NX4000_xc1_tpec0_regs 0xF4022500U
+#define NX4000_NETX_XC1_XTP0_BASE  0xF4022500U
+#define Addr_NX4000_xc1_rpec1_regs 0xF4022600U
+#define NX4000_NETX_XC1_XRP1_BASE  0xF4022600U
+#define Addr_NX4000_xc1_tpec1_regs 0xF4022700U
+#define NX4000_NETX_XC1_XTP1_BASE  0xF4022700U
+
+
+/* ===================================================================== */
+
+/* AREA xmac_ram */
+/* Area of xc0_rpu0_ram, xc0_tpu0_ram, xc0_rpu1_ram, xc0_tpu1_ram, xc1_rpu0_ram, xc1_tpu0_ram, xc1_rpu1_ram, xc1_tpu1_ram */
+
+/* ===================================================================== */
+
+#define Addr_NX4000_xc0_rpu0_ram 0xF4020000U
+#define Addr_NX4000_xc0_tpu0_ram 0xF4020400U
+#define Addr_NX4000_xc0_rpu1_ram 0xF4020800U
+#define Addr_NX4000_xc0_tpu1_ram 0xF4020C00U
+#define Addr_NX4000_xc1_rpu0_ram 0xF4021000U
+#define Addr_NX4000_xc1_tpu0_ram 0xF4021400U
+#define Addr_NX4000_xc1_rpu1_ram 0xF4021800U
+#define Addr_NX4000_xc1_tpu1_ram 0xF4021C00U
+
+/* --------------------------------------------------------------------- */
+/* Register xmac_ram_start */
+/* => xMAC RPU program-RAM start address. */
+/*    The Program-RAM is not addressable for xMAC RPU and TPU ! */
+/* => Mode:  */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_NX4000_xmac_ram_start          0x00000000U
+#define Adr_NX4000_xc0_rpu0_ram_xmac_ram_start 0xF4020000U
+#define Adr_NX4000_xc0_tpu0_ram_xmac_ram_start 0xF4020400U
+#define Adr_NX4000_xc0_rpu1_ram_xmac_ram_start 0xF4020800U
+#define Adr_NX4000_xc0_tpu1_ram_xmac_ram_start 0xF4020C00U
+#define Adr_NX4000_xc1_rpu0_ram_xmac_ram_start 0xF4021000U
+#define Adr_NX4000_xc1_tpu0_ram_xmac_ram_start 0xF4021400U
+#define Adr_NX4000_xc1_rpu1_ram_xmac_ram_start 0xF4021800U
+#define Adr_NX4000_xc1_tpu1_ram_xmac_ram_start 0xF4021C00U
+
+/* --------------------------------------------------------------------- */
+/* Register xmac_ram_end */
+/* => xMAC RPU program-RAM end address. */
+/*    This value is not used by design flow, only for documentation */
+/* => Mode:  */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_NX4000_xmac_ram_end          0x000003FCU
+#define Adr_NX4000_xc0_rpu0_ram_xmac_ram_end 0xF40203FCU
+#define Adr_NX4000_xc0_tpu0_ram_xmac_ram_end 0xF40207FCU
+#define Adr_NX4000_xc0_rpu1_ram_xmac_ram_end 0xF4020BFCU
+#define Adr_NX4000_xc0_tpu1_ram_xmac_ram_end 0xF4020FFCU
+#define Adr_NX4000_xc1_rpu0_ram_xmac_ram_end 0xF40213FCU
+#define Adr_NX4000_xc1_tpu0_ram_xmac_ram_end 0xF40217FCU
+#define Adr_NX4000_xc1_rpu1_ram_xmac_ram_end 0xF4021BFCU
+#define Adr_NX4000_xc1_tpu1_ram_xmac_ram_end 0xF4021FFCU
+
+/* --------------------------------------------------------------------- */
+/* Register ram_end */
+/* =>  */
+/* => Mode:  */
+/* --------------------------------------------------------------------- */
+
+#define REL_Adr_NX4000_ram_end            0x00001FFCU
+#define Adr_NX4000_xc0_rpec0_dram_ram_end 0xF4001FFCU
+#define Adr_NX4000_xc0_tpec0_dram_ram_end 0xF4003FFCU
+#define Adr_NX4000_xc0_rpec1_dram_ram_end 0xF4005FFCU
+#define Adr_NX4000_xc0_tpec1_dram_ram_end 0xF4007FFCU
+#define Adr_NX4000_xc1_rpec0_dram_ram_end 0xF4009FFCU
+#define Adr_NX4000_xc1_tpec0_dram_ram_end 0xF400BFFCU
+#define Adr_NX4000_xc1_rpec1_dram_ram_end 0xF400DFFCU
+#define Adr_NX4000_xc1_tpec1_dram_ram_end 0xF400FFFCU
+#define Adr_NX4000_xc0_rpec0_pram_ram_end 0xF4011FFCU
+#define Adr_NX4000_xc0_tpec0_pram_ram_end 0xF4013FFCU
+#define Adr_NX4000_xc0_rpec1_pram_ram_end 0xF4015FFCU
+#define Adr_NX4000_xc0_tpec1_pram_ram_end 0xF4017FFCU
+#define Adr_NX4000_xc1_rpec0_pram_ram_end 0xF4019FFCU
+#define Adr_NX4000_xc1_tpec0_pram_ram_end 0xF401BFFCU
+#define Adr_NX4000_xc1_rpec1_pram_ram_end 0xF401DFFCU
+#define Adr_NX4000_xc1_tpec1_pram_ram_end 0xF401FFFCU
+
+#define DFLT_VAL_NX4000_xmac_config_obu2           0x000007c8U
+
+#define MSK_NX4000_xmac_config_obu2_tx_nof_bits                    0x0000000fU
+#define SRT_NX4000_xmac_config_obu2_tx_nof_bits                    0
+#define DFLT_VAL_NX4000_xmac_config_obu2_tx_nof_bits               0x00000008U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu2_tx_nof_bits            0x00000008U
+#define MSK_NX4000_xmac_config_obu2_tx_shift_lr                    0x00000010U
+#define SRT_NX4000_xmac_config_obu2_tx_shift_lr                    4
+#define DFLT_VAL_NX4000_xmac_config_obu2_tx_shift_lr               0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu2_tx_shift_lr            0x00000000U
+#define MSK_NX4000_xmac_config_obu2_tx_count_stops_at_ovfl         0x00000020U
+#define SRT_NX4000_xmac_config_obu2_tx_count_stops_at_ovfl         5
+#define DFLT_VAL_NX4000_xmac_config_obu2_tx_count_stops_at_ovfl    0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu2_tx_count_stops_at_ovfl 0x00000000U
+#define MSK_NX4000_xmac_config_obu2_utx_watermark                  0x000007c0U
+#define SRT_NX4000_xmac_config_obu2_utx_watermark                  6
+#define DFLT_VAL_NX4000_xmac_config_obu2_utx_watermark             0x000007c0U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu2_utx_watermark          0x0000001fU
+#define MSK_NX4000_xmac_config_obu2_tx_clk_phase                   0x00003800U
+#define SRT_NX4000_xmac_config_obu2_tx_clk_phase                   11
+#define DFLT_VAL_NX4000_xmac_config_obu2_tx_clk_phase              0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu2_tx_clk_phase           0x00000000U
+
+/* all used bits of 'NX4000_xmac_config_obu2': */
+#define MSK_USED_BITS_NX4000_xmac_config_obu2 0x00003fffU
+
+#define DFLT_VAL_NX4000_xmac_config_sbu2           0x00000008U
+
+#define MSK_NX4000_xmac_config_sbu2_rx_nof_bits                    0x0000000fU
+#define SRT_NX4000_xmac_config_sbu2_rx_nof_bits                    0
+#define DFLT_VAL_NX4000_xmac_config_sbu2_rx_nof_bits               0x00000008U
+#define DFLT_BF_VAL_NX4000_xmac_config_sbu2_rx_nof_bits            0x00000008U
+#define MSK_NX4000_xmac_config_sbu2_rx_shift_lr                    0x00000010U
+#define SRT_NX4000_xmac_config_sbu2_rx_shift_lr                    4
+#define DFLT_VAL_NX4000_xmac_config_sbu2_rx_shift_lr               0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_sbu2_rx_shift_lr            0x00000000U
+#define MSK_NX4000_xmac_config_sbu2_rx_count_stops_at_ovfl         0x00000020U
+#define SRT_NX4000_xmac_config_sbu2_rx_count_stops_at_ovfl         5
+#define DFLT_VAL_NX4000_xmac_config_sbu2_rx_count_stops_at_ovfl    0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_sbu2_rx_count_stops_at_ovfl 0x00000000U
+#define MSK_NX4000_xmac_config_sbu2_urx_write_odd                  0x00000040U
+#define SRT_NX4000_xmac_config_sbu2_urx_write_odd                  6
+#define DFLT_VAL_NX4000_xmac_config_sbu2_urx_write_odd             0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_sbu2_urx_write_odd          0x00000000U
+#define MSK_NX4000_xmac_config_sbu2_rx_clk_phase                   0x00000380U
+#define SRT_NX4000_xmac_config_sbu2_rx_clk_phase                   7
+#define DFLT_VAL_NX4000_xmac_config_sbu2_rx_clk_phase              0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_sbu2_rx_clk_phase           0x00000000U
+
+/* all used bits of 'NX4000_xmac_config_sbu2': */
+#define MSK_USED_BITS_NX4000_xmac_config_sbu2 0x000003ffU
+
+#define DFLT_VAL_NX4000_xmac_config_rx_nibble_fifo           0x00001000U
+
+#define MSK_NX4000_xmac_config_rx_nibble_fifo_sample_phase              0x00000007U
+#define SRT_NX4000_xmac_config_rx_nibble_fifo_sample_phase              0
+#define DFLT_VAL_NX4000_xmac_config_rx_nibble_fifo_sample_phase         0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_rx_nibble_fifo_sample_phase      0x00000000U
+#define MSK_NX4000_xmac_config_rx_nibble_fifo_delay_rx_data             0x00000008U
+#define SRT_NX4000_xmac_config_rx_nibble_fifo_delay_rx_data             3
+#define DFLT_VAL_NX4000_xmac_config_rx_nibble_fifo_delay_rx_data        0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_rx_nibble_fifo_delay_rx_data     0x00000000U
+#define MSK_NX4000_xmac_config_rx_nibble_fifo_fifo_depth_add            0x00000030U
+#define SRT_NX4000_xmac_config_rx_nibble_fifo_fifo_depth_add            4
+#define DFLT_VAL_NX4000_xmac_config_rx_nibble_fifo_fifo_depth_add       0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_rx_nibble_fifo_fifo_depth_add    0x00000000U
+#define MSK_NX4000_xmac_config_rx_nibble_fifo_fifo_depth                0x000003c0U
+#define SRT_NX4000_xmac_config_rx_nibble_fifo_fifo_depth                6
+#define DFLT_VAL_NX4000_xmac_config_rx_nibble_fifo_fifo_depth           0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_rx_nibble_fifo_fifo_depth        0x00000000U
+#define MSK_NX4000_xmac_config_rx_nibble_fifo_rx_write_phase            0x00000c00U
+#define SRT_NX4000_xmac_config_rx_nibble_fifo_rx_write_phase            10
+#define DFLT_VAL_NX4000_xmac_config_rx_nibble_fifo_rx_write_phase       0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_rx_nibble_fifo_rx_write_phase    0x00000000U
+#define MSK_NX4000_xmac_config_rx_nibble_fifo_rpu_sync_delay            0x00003000U
+#define SRT_NX4000_xmac_config_rx_nibble_fifo_rpu_sync_delay            12
+#define DFLT_VAL_NX4000_xmac_config_rx_nibble_fifo_rpu_sync_delay       0x00001000U
+#define DFLT_BF_VAL_NX4000_xmac_config_rx_nibble_fifo_rpu_sync_delay    0x00000001U
+#define MSK_NX4000_xmac_config_rx_nibble_fifo_rx_err_low_active         0x00004000U
+#define SRT_NX4000_xmac_config_rx_nibble_fifo_rx_err_low_active         14
+#define DFLT_VAL_NX4000_xmac_config_rx_nibble_fifo_rx_err_low_active    0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_rx_nibble_fifo_rx_err_low_active 0x00000000U
+#define MSK_NX4000_xmac_config_rx_nibble_fifo_crs_low_active            0x00008000U
+#define SRT_NX4000_xmac_config_rx_nibble_fifo_crs_low_active            15
+#define DFLT_VAL_NX4000_xmac_config_rx_nibble_fifo_crs_low_active       0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_rx_nibble_fifo_crs_low_active    0x00000000U
+
+/* all used bits of 'NX4000_xmac_config_rx_nibble_fifo': */
+#define MSK_USED_BITS_NX4000_xmac_config_rx_nibble_fifo 0x0000ffffU
+
+#define DFLT_VAL_NX4000_xmac_config_mii           0x00000000U
+
+#define MSK_NX4000_xmac_config_mii_tx_en                            0x00000001U
+#define SRT_NX4000_xmac_config_mii_tx_en                            0
+#define DFLT_VAL_NX4000_xmac_config_mii_tx_en                       0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_mii_tx_en                    0x00000000U
+#define MSK_NX4000_xmac_config_mii_tx_err                           0x00000002U
+#define SRT_NX4000_xmac_config_mii_tx_err                           1
+#define DFLT_VAL_NX4000_xmac_config_mii_tx_err                      0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_mii_tx_err                   0x00000000U
+#define MSK_NX4000_xmac_config_mii_txd_oe_switch_with_tx_en         0x00000004U
+#define SRT_NX4000_xmac_config_mii_txd_oe_switch_with_tx_en         2
+#define DFLT_VAL_NX4000_xmac_config_mii_txd_oe_switch_with_tx_en    0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_mii_txd_oe_switch_with_tx_en 0x00000000U
+#define MSK_NX4000_xmac_config_mii_data_reserved                    0x000000f8U
+#define SRT_NX4000_xmac_config_mii_data_reserved                    3
+#define DFLT_VAL_NX4000_xmac_config_mii_data_reserved               0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_mii_data_reserved            0x00000000U
+
+/* all used bits of 'NX4000_xmac_config_mii': */
+#define MSK_USED_BITS_NX4000_xmac_config_mii 0x000000ffU
+
+#define DFLT_VAL_NX4000_xmac_config_obu           0x00000180U
+
+#define MSK_NX4000_xmac_config_obu_sync_to_eclk                         0x00000001U
+#define SRT_NX4000_xmac_config_obu_sync_to_eclk                         0
+#define DFLT_VAL_NX4000_xmac_config_obu_sync_to_eclk                    0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_sync_to_eclk                 0x00000000U
+#define MSK_NX4000_xmac_config_obu_sync_to_bitstream                    0x00000002U
+#define SRT_NX4000_xmac_config_obu_sync_to_bitstream                    1
+#define DFLT_VAL_NX4000_xmac_config_obu_sync_to_bitstream               0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_sync_to_bitstream            0x00000000U
+#define MSK_NX4000_xmac_config_obu_sync_to_posedge                      0x00000004U
+#define SRT_NX4000_xmac_config_obu_sync_to_posedge                      2
+#define DFLT_VAL_NX4000_xmac_config_obu_sync_to_posedge                 0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_sync_to_posedge              0x00000000U
+#define MSK_NX4000_xmac_config_obu_sync_to_negedge                      0x00000008U
+#define SRT_NX4000_xmac_config_obu_sync_to_negedge                      3
+#define DFLT_VAL_NX4000_xmac_config_obu_sync_to_negedge                 0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_sync_to_negedge              0x00000000U
+#define MSK_NX4000_xmac_config_obu_count_modulo                         0x00000010U
+#define SRT_NX4000_xmac_config_obu_count_modulo                         4
+#define DFLT_VAL_NX4000_xmac_config_obu_count_modulo                    0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_count_modulo                 0x00000000U
+#define MSK_NX4000_xmac_config_obu_invert_tx_oe                         0x00000020U
+#define SRT_NX4000_xmac_config_obu_invert_tx_oe                         5
+#define DFLT_VAL_NX4000_xmac_config_obu_invert_tx_oe                    0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_invert_tx_oe                 0x00000000U
+#define MSK_NX4000_xmac_config_obu_predivide_clk                        0x00000040U
+#define SRT_NX4000_xmac_config_obu_predivide_clk                        6
+#define DFLT_VAL_NX4000_xmac_config_obu_predivide_clk                   0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_predivide_clk                0x00000000U
+#define MSK_NX4000_xmac_config_obu_tx_three_state                       0x00000080U
+#define SRT_NX4000_xmac_config_obu_tx_three_state                       7
+#define DFLT_VAL_NX4000_xmac_config_obu_tx_three_state                  0x00000080U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_tx_three_state               0x00000001U
+#define MSK_NX4000_xmac_config_obu_eclk_noe                             0x00000100U
+#define SRT_NX4000_xmac_config_obu_eclk_noe                             8
+#define DFLT_VAL_NX4000_xmac_config_obu_eclk_noe                        0x00000100U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_eclk_noe                     0x00000001U
+#define MSK_NX4000_xmac_config_obu_sample_bitstream_eclk                0x00000200U
+#define SRT_NX4000_xmac_config_obu_sample_bitstream_eclk                9
+#define DFLT_VAL_NX4000_xmac_config_obu_sample_bitstream_eclk           0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_sample_bitstream_eclk        0x00000000U
+#define MSK_NX4000_xmac_config_obu_repeat_bit_at_sync                   0x00000400U
+#define SRT_NX4000_xmac_config_obu_repeat_bit_at_sync                   10
+#define DFLT_VAL_NX4000_xmac_config_obu_repeat_bit_at_sync              0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_repeat_bit_at_sync           0x00000000U
+#define MSK_NX4000_xmac_config_obu_disable_sync_in_output_phase         0x00000800U
+#define SRT_NX4000_xmac_config_obu_disable_sync_in_output_phase         11
+#define DFLT_VAL_NX4000_xmac_config_obu_disable_sync_in_output_phase    0x00000000U
+#define DFLT_BF_VAL_NX4000_xmac_config_obu_disable_sync_in_output_phase 0x00000000U
+
+/* all used bits of 'NX4000_xmac_config_obu': */
+#define MSK_USED_BITS_NX4000_xmac_config_obu 0x00000fffU
+
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_start_rpec0         0x00000001U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_start_rpec0         0
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_start_rpec0    0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_start_rpec0 0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_start_tpec0         0x00000002U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_start_tpec0         1
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_start_tpec0    0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_start_tpec0 0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_start_rpu0          0x00000004U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_start_rpu0          2
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_start_rpu0     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_start_rpu0  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_start_tpu0          0x00000008U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_start_tpu0          3
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_start_tpu0     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_start_tpu0  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_start_rpec1         0x00000010U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_start_rpec1         4
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_start_rpec1    0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_start_rpec1 0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_start_tpec1         0x00000020U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_start_tpec1         5
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_start_tpec1    0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_start_tpec1 0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_start_rpu1          0x00000040U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_start_rpu1          6
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_start_rpu1     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_start_rpu1  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_start_tpu1          0x00000080U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_start_tpu1          7
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_start_tpu1     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_start_tpu1  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_start_rpec0         0x00000100U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_start_rpec0         8
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_start_rpec0    0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_start_rpec0 0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_start_tpec0         0x00000200U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_start_tpec0         9
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_start_tpec0    0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_start_tpec0 0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_start_rpu0          0x00000400U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_start_rpu0          10
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_start_rpu0     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_start_rpu0  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_start_tpu0          0x00000800U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_start_tpu0          11
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_start_tpu0     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_start_tpu0  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_start_rpec1         0x00001000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_start_rpec1         12
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_start_rpec1    0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_start_rpec1 0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_start_tpec1         0x00002000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_start_tpec1         13
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_start_tpec1    0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_start_tpec1 0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_start_rpu1          0x00004000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_start_rpu1          14
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_start_rpu1     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_start_rpu1  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_start_tpu1          0x00008000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_start_tpu1          15
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_start_tpu1     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_start_tpu1  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_stop_rpec0          0x00010000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_stop_rpec0          16
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_rpec0     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_rpec0  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_stop_tpec0          0x00020000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_stop_tpec0          17
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_tpec0     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_tpec0  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_stop_rpu0           0x00040000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_stop_rpu0           18
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_rpu0      0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_rpu0   0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_stop_tpu0           0x00080000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_stop_tpu0           19
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_tpu0      0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_tpu0   0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_stop_rpec1          0x00100000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_stop_rpec1          20
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_rpec1     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_rpec1  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_stop_tpec1          0x00200000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_stop_tpec1          21
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_tpec1     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_tpec1  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_stop_rpu1           0x00400000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_stop_rpu1           22
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_rpu1      0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_rpu1   0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc0_stop_tpu1           0x00800000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc0_stop_tpu1           23
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_tpu1      0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc0_stop_tpu1   0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_stop_rpec0          0x01000000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_stop_rpec0          24
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_rpec0     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_rpec0  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_stop_tpec0          0x02000000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_stop_tpec0          25
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_tpec0     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_tpec0  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_stop_rpu0           0x04000000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_stop_rpu0           26
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_rpu0      0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_rpu0   0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_stop_tpu0           0x08000000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_stop_tpu0           27
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_tpu0      0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_tpu0   0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_stop_rpec1          0x10000000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_stop_rpec1          28
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_rpec1     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_rpec1  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_stop_tpec1          0x20000000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_stop_tpec1          29
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_tpec1     0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_tpec1  0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_stop_rpu1           0x40000000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_stop_rpu1           30
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_rpu1      0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_rpu1   0x00000000U
+#define MSK_NX4000_xc_start_stop_ctrl_xc1_stop_tpu1           0x80000000U
+#define SRT_NX4000_xc_start_stop_ctrl_xc1_stop_tpu1           31
+#define DFLT_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_tpu1      0x00000000U
+#define DFLT_BF_VAL_NX4000_xc_start_stop_ctrl_xc1_stop_tpu1   0x00000000U
+
+/* all used bits of 'NX4000_xc_start_stop_ctrl': */
+#define MSK_USED_BITS_NX4000_xc_start_stop_ctrl 0xffffffffU
+
+#define MSK_NX4000_xpec_config_timer0                  0x00000007U
+#define SRT_NX4000_xpec_config_timer0                  0
+#define DFLT_VAL_NX4000_xpec_config_timer0             0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_timer0          0x00000000U
+#define MSK_NX4000_xpec_config_timer1                  0x00000038U
+#define SRT_NX4000_xpec_config_timer1                  3
+#define DFLT_VAL_NX4000_xpec_config_timer1             0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_timer1          0x00000000U
+#define MSK_NX4000_xpec_config_timer2                  0x000001c0U
+#define SRT_NX4000_xpec_config_timer2                  6
+#define DFLT_VAL_NX4000_xpec_config_timer2             0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_timer2          0x00000000U
+#define MSK_NX4000_xpec_config_timer3                  0x00000e00U
+#define SRT_NX4000_xpec_config_timer3                  9
+#define DFLT_VAL_NX4000_xpec_config_timer3             0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_timer3          0x00000000U
+#define MSK_NX4000_xpec_config_timer4                  0x00007000U
+#define SRT_NX4000_xpec_config_timer4                  12
+#define DFLT_VAL_NX4000_xpec_config_timer4             0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_timer4          0x00000000U
+#define MSK_NX4000_xpec_config_timer5                  0x00038000U
+#define SRT_NX4000_xpec_config_timer5                  15
+#define DFLT_VAL_NX4000_xpec_config_timer5             0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_timer5          0x00000000U
+#define MSK_NX4000_xpec_config_register_mode           0x00300000U
+#define SRT_NX4000_xpec_config_register_mode           20
+#define DFLT_VAL_NX4000_xpec_config_register_mode      0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_register_mode   0x00000000U
+#define MSK_NX4000_xpec_config_reset_urx_fifo0         0x01000000U
+#define SRT_NX4000_xpec_config_reset_urx_fifo0         24
+#define DFLT_VAL_NX4000_xpec_config_reset_urx_fifo0    0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_reset_urx_fifo0 0x00000000U
+#define MSK_NX4000_xpec_config_reset_utx_fifo0         0x02000000U
+#define SRT_NX4000_xpec_config_reset_utx_fifo0         25
+#define DFLT_VAL_NX4000_xpec_config_reset_utx_fifo0    0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_reset_utx_fifo0 0x00000000U
+#define MSK_NX4000_xpec_config_reset_urx_fifo1         0x04000000U
+#define SRT_NX4000_xpec_config_reset_urx_fifo1         26
+#define DFLT_VAL_NX4000_xpec_config_reset_urx_fifo1    0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_reset_urx_fifo1 0x00000000U
+#define MSK_NX4000_xpec_config_reset_utx_fifo1         0x08000000U
+#define SRT_NX4000_xpec_config_reset_utx_fifo1         27
+#define DFLT_VAL_NX4000_xpec_config_reset_utx_fifo1    0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_reset_utx_fifo1 0x00000000U
+#define MSK_NX4000_xpec_config_reset_eld0              0x10000000U
+#define SRT_NX4000_xpec_config_reset_eld0              28
+#define DFLT_VAL_NX4000_xpec_config_reset_eld0         0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_reset_eld0      0x00000000U
+#define MSK_NX4000_xpec_config_reset_eld1              0x20000000U
+#define SRT_NX4000_xpec_config_reset_eld1              29
+#define DFLT_VAL_NX4000_xpec_config_reset_eld1         0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_reset_eld1      0x00000000U
+#define MSK_NX4000_xpec_config_debug_mode              0x40000000U
+#define SRT_NX4000_xpec_config_debug_mode              30
+#define DFLT_VAL_NX4000_xpec_config_debug_mode         0x00000000U
+#define DFLT_BF_VAL_NX4000_xpec_config_debug_mode      0x00000000U
+
+typedef struct NX4000_XC_START_STOP_AREA_Ttag
+{
+	volatile uint32_t ulXc_start_stop_ctrl;
+	volatile uint32_t ulXc_hold_status;
+} NX4000_XC_START_STOP_AREA_T;
+
+typedef struct NX4000_XMAC_AREA_Ttag
+{
+  volatile uint32_t aulXmac_sr[16];
+  volatile uint32_t  ulXmac_status_shared0;
+  volatile uint32_t  ulXmac_config_shared0;
+  volatile uint32_t  ulXmac_io_oe_shared0;
+  volatile uint32_t  ulXmac_status_shared1;
+  volatile uint32_t  ulXmac_config_shared1;
+  volatile uint32_t  ulXmac_io_oe_shared1;
+  volatile uint32_t aulReserved0[6];
+  volatile uint32_t aulXmac_urx_utx[2];
+  volatile uint32_t aulReserved1[2];
+  volatile uint32_t  ulXmac_urx;
+  volatile uint32_t  ulXmac_utx;
+  volatile uint32_t  ulXmac_rx;
+  volatile uint32_t  ulXmac_other_rx;
+  volatile uint32_t  ulXmac_rx_hw;
+  volatile uint32_t  ulXmac_rx_hw_count;
+  volatile uint32_t  ulXmac_tx;
+  volatile uint32_t  ulXmac_tx_hw;
+  volatile uint32_t  ulXmac_tx_hw_count;
+  volatile uint32_t  ulXmac_tx_sent;
+  volatile uint32_t  ulXmac_rpu_pc;
+  volatile uint32_t  ulXmac_rpu_jmp_latch;
+  volatile uint32_t  ulXmac_tpu_pc;
+  volatile uint32_t  ulXmac_tpu_jmp_latch;
+  volatile uint32_t aulXmac_wr[10];
+  volatile uint32_t  ulXmac_sys_time;
+  volatile uint32_t  ulXmac_sys_time_upper;
+  volatile uint32_t  ulXmac_sys_time_uc;
+  volatile uint32_t  ulXmac_sys_time_uc_upper;
+  volatile uint32_t aulXmac_cmp_status[5];
+  volatile uint32_t  ulXmac_alu_flags;
+  volatile uint32_t  ulXmac_status_int;
+  volatile uint32_t  ulXmac_stat_bits;
+  volatile uint32_t  ulXmac_stat_bits_shared_lower;
+  volatile uint32_t  ulXmac_stat_bits_shared_upper;
+  volatile uint32_t  ulXmac_status_mii;
+  volatile uint32_t  ulXmac_status_mii2;
+  volatile uint32_t  ulXmac_other_status_mii2;
+  volatile uint32_t  ulXmac_config_mii;
+  volatile uint32_t  ulXmac_config_rx_nibble_fifo;
+  volatile uint32_t  ulXmac_config_tx_nibble_fifo;
+  volatile uint32_t  ulXmac_config_sbu;
+  volatile uint32_t  ulXmac_config_sbu2;
+  volatile uint32_t  ulXmac_sbu_rate_mul_add;
+  volatile uint32_t  ulXmac_sbu_rate_mul_start;
+  volatile uint32_t  ulXmac_sbu_rate_mul;
+  volatile uint32_t  ulXmac_start_sample_pos;
+  volatile uint32_t  ulXmac_stop_sample_pos;
+  volatile uint32_t  ulXmac_config_obu;
+  volatile uint32_t  ulXmac_config_obu2;
+  volatile uint32_t  ulXmac_obu_rate_mul_add;
+  volatile uint32_t  ulXmac_obu_rate_mul_start;
+  volatile uint32_t  ulXmac_obu_rate_mul;
+  volatile uint32_t  ulXmac_start_trans_pos;
+  volatile uint32_t  ulXmac_stop_trans_pos;
+  volatile uint32_t  ulXmac_rpu_count1;
+  volatile uint32_t  ulXmac_rpu_count2;
+  volatile uint32_t  ulXmac_tpu_count1;
+  volatile uint32_t  ulXmac_tpu_count2;
+  volatile uint32_t  ulXmac_rx_count;
+  volatile uint32_t  ulXmac_tx_count;
+  volatile uint32_t  ulXmac_rpm_mask0;
+  volatile uint32_t  ulXmac_rpm_val0;
+  volatile uint32_t  ulXmac_rpm_mask1;
+  volatile uint32_t  ulXmac_rpm_val1;
+  volatile uint32_t  ulXmac_tpm_mask0;
+  volatile uint32_t  ulXmac_tpm_val0;
+  volatile uint32_t  ulXmac_tpm_mask1;
+  volatile uint32_t  ulXmac_tpm_val1;
+  volatile uint32_t aulReserved2[8];
+  volatile uint32_t  ulXmac_rx_crc32_l;
+  volatile uint32_t  ulXmac_rx_crc32_h;
+  volatile uint32_t  ulXmac_rx_crc32_cfg;
+  volatile uint32_t  ulXmac_tx_crc32_l;
+  volatile uint32_t  ulXmac_tx_crc32_h;
+  volatile uint32_t  ulXmac_tx_crc32_cfg;
+  volatile uint32_t  ulXmac_rx_crc_polynomial_l;
+  volatile uint32_t  ulXmac_rx_crc_polynomial_h;
+  volatile uint32_t  ulXmac_rx_crc_l;
+  volatile uint32_t  ulXmac_rx_crc_h;
+  volatile uint32_t  ulXmac_rx_crc_cfg;
+  volatile uint32_t  ulXmac_tx_crc_polynomial_l;
+  volatile uint32_t  ulXmac_tx_crc_polynomial_h;
+  volatile uint32_t  ulXmac_tx_crc_l;
+  volatile uint32_t  ulXmac_tx_crc_h;
+  volatile uint32_t  ulXmac_tx_crc_cfg;
+} NX4000_XMAC_AREA_T;
+
+typedef struct NX4000_XPEC_AREA_Ttag
+{
+  volatile uint32_t aulXpec_r[8];
+  volatile uint32_t  ulXpec_stat_bits_shared;
+  volatile uint32_t  ulRange_urtx_count;
+  volatile uint32_t  ulRange45;
+  volatile uint32_t  ulRange67;
+  volatile uint32_t aulTimer[4];
+  volatile uint32_t  ulUrx_count;
+  volatile uint32_t  ulUtx_count;
+  volatile uint32_t  ulXpec_pc;
+  volatile uint32_t  ulZero;
+  volatile uint32_t  ulXpec_config;
+  volatile uint32_t  ulEc_maska;
+  volatile uint32_t  ulEc_maskb;
+  volatile uint32_t aulEc_mask[10];
+  volatile uint32_t  ulTimer4;
+  volatile uint32_t  ulTimer5;
+  volatile uint32_t  ulIrq;
+  volatile uint32_t  ulXpec_systime_ns;
+  volatile uint32_t  ulFifo_data;
+  volatile uint32_t  ulXpec_systime_s;
+  volatile uint32_t  ulDatach_data;
+  volatile uint32_t aulXpec_sr[16];
+  volatile uint32_t aulStatcfg[2];
+  volatile uint32_t  ulDatach_wr_cfg;
+  volatile uint32_t  ulDatach_rd_cfg;
+  volatile uint32_t aulUrtx[2];
+  volatile uint32_t  ulSysch_data;
+  volatile uint32_t  ulSysch_addr;
+} NX4000_XPEC_AREA_T;
+
+#define Addr_NX4000_xc_start_stop 0xF4023A80U
+#define HW_PTR_XC_START_STOP(var)      static NX4000_XC_START_STOP_AREA_T*        const var   = (NX4000_XC_START_STOP_AREA_T*) Addr_NX4000_xc_start_stop;
+
+#define Addr_NX4000_xc0_rpec0_regs 0xF4022000U
+#define Addr_NX4000_xc0_rpec1_regs 0xF4022200U
+#define Addr_NX4000_xc1_rpec0_regs 0xF4022400U
+#define Addr_NX4000_xc1_rpec1_regs 0xF4022600U
+#define HW_PTR_RPEC_REGS(var)          static NX4000_XPEC_AREA_T* const var[] = \
+{\
+	(NX4000_XPEC_AREA_T*) Addr_NX4000_xc0_rpec0_regs,\
+	(NX4000_XPEC_AREA_T*) Addr_NX4000_xc0_rpec1_regs,\
+	(NX4000_XPEC_AREA_T*) Addr_NX4000_xc1_rpec0_regs,\
+	(NX4000_XPEC_AREA_T*) Addr_NX4000_xc1_rpec1_regs\
+};
+
+#define Adr_NX4000_xc0_rpu0_ram_xmac_ram_end 0xF40203FCU
+#define Adr_NX4000_xc0_rpu1_ram_xmac_ram_end 0xF4020BFCU
+#define Adr_NX4000_xc1_rpu0_ram_xmac_ram_end 0xF40213FCU
+#define Adr_NX4000_xc1_rpu1_ram_xmac_ram_end 0xF4021BFCU
+#define HW_PTR_RPU_PRAM_END(var)       static uint32_t* const var[] = \
+{\
+	(uint32_t*)  Adr_NX4000_xc0_rpu0_ram_xmac_ram_end,\
+	(uint32_t*)  Adr_NX4000_xc0_rpu1_ram_xmac_ram_end,\
+	(uint32_t*)  Adr_NX4000_xc1_rpu0_ram_xmac_ram_end,\
+	(uint32_t*)  Adr_NX4000_xc1_rpu1_ram_xmac_ram_end\
+};
+
+#define Adr_NX4000_xc0_tpec0_pram_ram_end 0xF4013FFCU
+#define Adr_NX4000_xc0_tpec1_pram_ram_end 0xF4017FFCU
+#define Adr_NX4000_xc1_tpec0_pram_ram_end 0xF401BFFCU
+#define Adr_NX4000_xc1_tpec1_pram_ram_end 0xF401FFFCU
+#define HW_PTR_TPEC_PRAM_END(var)      static uint32_t* const var[] = \
+{\
+	(uint32_t*) Adr_NX4000_xc0_tpec0_pram_ram_end,\
+	(uint32_t*) Adr_NX4000_xc0_tpec1_pram_ram_end,\
+	(uint32_t*) Adr_NX4000_xc1_tpec0_pram_ram_end,\
+	(uint32_t*) Adr_NX4000_xc1_tpec1_pram_ram_end\
+};
+
+#define Adr_NX4000_xc0_tpu0_ram_xmac_ram_start 0xF4020400U
+#define Adr_NX4000_xc0_tpu1_ram_xmac_ram_start 0xF4020C00U
+#define Adr_NX4000_xc1_tpu0_ram_xmac_ram_start 0xF4021400U
+#define Adr_NX4000_xc1_tpu1_ram_xmac_ram_start 0xF4021C00U
+#define HW_PTR_TPU_PRAM_START(var)     static uint32_t* const var[] = \
+{\
+	(uint32_t*)  Adr_NX4000_xc0_tpu0_ram_xmac_ram_start,\
+	(uint32_t*)  Adr_NX4000_xc0_tpu1_ram_xmac_ram_start,\
+	(uint32_t*)  Adr_NX4000_xc1_tpu0_ram_xmac_ram_start,\
+	(uint32_t*)  Adr_NX4000_xc1_tpu1_ram_xmac_ram_start\
+};
+
+#define Addr_NX4000_xc0_tpec0_regs 0xF4022100U
+#define Addr_NX4000_xc0_rpec1_regs 0xF4022200U
+#define Addr_NX4000_xc1_rpec0_regs 0xF4022400U
+#define Addr_NX4000_xc1_rpec1_regs 0xF4022600U
+#define HW_PTR_TPEC_REGS(var)          static NX4000_XPEC_AREA_T* const var[] = \
+{\
+	(NX4000_XPEC_AREA_T*) Addr_NX4000_xc0_tpec0_regs,\
+	(NX4000_XPEC_AREA_T*) Addr_NX4000_xc0_tpec1_regs,\
+	(NX4000_XPEC_AREA_T*) Addr_NX4000_xc1_tpec0_regs,\
+	(NX4000_XPEC_AREA_T*) Addr_NX4000_xc1_tpec1_regs\
+};
+
+#define Adr_NX4000_xc0_rpec0_pram_ram_end 0xF4011FFCU
+#define Adr_NX4000_xc0_rpec1_pram_ram_end 0xF4015FFCU
+#define Adr_NX4000_xc1_rpec0_pram_ram_end 0xF4019FFCU
+#define Adr_NX4000_xc1_rpec1_pram_ram_end 0xF401DFFCU
+#define HW_PTR_RPEC_PRAM_END(var)      static uint32_t* const var[] = \
+{\
+	(uint32_t*) Adr_NX4000_xc0_rpec0_pram_ram_end,\
+	(uint32_t*) Adr_NX4000_xc0_rpec1_pram_ram_end,\
+	(uint32_t*) Adr_NX4000_xc1_rpec0_pram_ram_end,\
+	(uint32_t*) Adr_NX4000_xc1_rpec1_pram_ram_end\
+};
+
+#define Addr_NX4000_xc0_xmac0_regs 0xF4022800U
+#define Addr_NX4000_xc0_xmac1_regs 0xF4022A00U
+#define Addr_NX4000_xc1_xmac0_regs 0xF4022C00U
+#define Addr_NX4000_xc1_xmac1_regs 0xF4022E00U
+#define HW_PTR_XMAC(var)               static NX4000_XMAC_AREA_T* const var[] = \
+{\
+(NX4000_XMAC_AREA_T*) Addr_NX4000_xc0_xmac0_regs,\
+	(NX4000_XMAC_AREA_T*) Addr_NX4000_xc0_xmac1_regs,\
+	(NX4000_XMAC_AREA_T*) Addr_NX4000_xc1_xmac0_regs,\
+	(NX4000_XMAC_AREA_T*) Addr_NX4000_xc1_xmac1_regs\
+};
+
+#define Adr_NX4000_xc0_tpu0_ram_xmac_ram_end 0xF40207FCU
+#define Adr_NX4000_xc0_tpu1_ram_xmac_ram_end 0xF4020FFCU
+#define Adr_NX4000_xc1_tpu0_ram_xmac_ram_end 0xF40217FCU
+#define Adr_NX4000_xc1_tpu1_ram_xmac_ram_end 0xF4021FFCU
+#define HW_PTR_TPU_PRAM_END(var)       static uint32_t* const var[] = \
+{\
+	(uint32_t*)  Adr_NX4000_xc0_tpu0_ram_xmac_ram_end,\
+	(uint32_t*)  Adr_NX4000_xc0_tpu1_ram_xmac_ram_end,\
+	(uint32_t*)  Adr_NX4000_xc1_tpu0_ram_xmac_ram_end,\
+	(uint32_t*)  Adr_NX4000_xc1_tpu1_ram_xmac_ram_end\
+};
+
+#define Adr_NX4000_xc0_rpu0_ram_xmac_ram_end 0xF40203FCU
+#define Adr_NX4000_xc0_rpu1_ram_xmac_ram_end 0xF4020BFCU
+#define Adr_NX4000_xc1_rpu0_ram_xmac_ram_end 0xF40213FCU
+#define Adr_NX4000_xc1_rpu1_ram_xmac_ram_end 0xF4021BFCU
+#define HW_PTR_RPU_PRAM_END(var)       static uint32_t* const var[] = \
+{\
+	(uint32_t*)  Adr_NX4000_xc0_rpu0_ram_xmac_ram_end,\
+	(uint32_t*)  Adr_NX4000_xc0_rpu1_ram_xmac_ram_end,\
+	(uint32_t*)  Adr_NX4000_xc1_rpu0_ram_xmac_ram_end,\
+	(uint32_t*)  Adr_NX4000_xc1_rpu1_ram_xmac_ram_end\
+};
+
+
+#define Adr_NX4000_xc0_tpec0_pram_ram_start 0xF4012000U
+#define Adr_NX4000_xc0_tpec1_pram_ram_start 0xF4016000U
+#define Adr_NX4000_xc1_tpec0_pram_ram_start 0xF401A000U
+#define Adr_NX4000_xc1_tpec1_pram_ram_start 0xF401E000U
+#define HW_PTR_TPEC_PRAM_START(var)    static uint32_t* const var[] = \
+{\
+	(uint32_t*) Adr_NX4000_xc0_tpec0_pram_ram_start,\
+	(uint32_t*) Adr_NX4000_xc0_tpec1_pram_ram_start,\
+	(uint32_t*) Adr_NX4000_xc1_tpec0_pram_ram_start,\
+	(uint32_t*) Adr_NX4000_xc1_tpec1_pram_ram_start\
+};
+
+#define Adr_NX4000_xc0_rpu0_ram_xmac_ram_start 0xF4020000U
+#define Adr_NX4000_xc0_rpu1_ram_xmac_ram_start 0xF4020800U
+#define Adr_NX4000_xc1_rpu0_ram_xmac_ram_start 0xF4021000U
+#define Adr_NX4000_xc1_rpu1_ram_xmac_ram_start 0xF4021800U
+#define HW_PTR_RPU_PRAM_START(var)     static uint32_t* const var[] = \
+{\
+	(uint32_t*)  Adr_NX4000_xc0_rpu0_ram_xmac_ram_start,\
+	(uint32_t*)  Adr_NX4000_xc0_rpu1_ram_xmac_ram_start,\
+	(uint32_t*)  Adr_NX4000_xc1_rpu0_ram_xmac_ram_start,\
+	(uint32_t*)  Adr_NX4000_xc1_rpu1_ram_xmac_ram_start\
+};
+
+#define Adr_NX4000_xc0_rpec0_pram_ram_start 0xF4010000U
+#define Adr_NX4000_xc0_rpec1_pram_ram_start 0xF4014000U
+#define Adr_NX4000_xc1_rpec0_pram_ram_start 0xF4018000U
+#define Adr_NX4000_xc1_rpec1_pram_ram_start 0xF401C000U
+#define HW_PTR_RPEC_PRAM_START(var)    static uint32_t* const var[] = \
+{\
+	(uint32_t*) Adr_NX4000_xc0_rpec0_pram_ram_start,\
+	(uint32_t*) Adr_NX4000_xc0_rpec1_pram_ram_start,\
+	(uint32_t*) Adr_NX4000_xc1_rpec0_pram_ram_start,\
+	(uint32_t*) Adr_NX4000_xc1_rpec1_pram_ram_start\
+};
+
+#define Addr_NX4000_xc0_pointer_fifo        0xF4023000U
+#define Addr_NX4000_xc1_pointer_fifo        0xF4023200U
+
+#define Adr_NX4000_xc0_tpec0_dram_ram_start 0xF4002000U
+#define Adr_NX4000_xc0_tpec1_dram_ram_start 0xF4006000U
+#define Adr_NX4000_xc1_tpec1_dram_ram_start 0xF400E000U
+#define Adr_NX4000_xc1_tpec0_dram_ram_start 0xF400A000U
+
+
+#define Adr_NX4000_xc0_irq_xpec0                       0xF4023A60U
+#define Adr_NX4000_xc0_irq_xpec1                       0xF4023A64U
+#define Adr_NX4000_xc1_irq_xpec0                       0xF4023A68U
+#define Adr_NX4000_xc1_irq_xpec1                       0xF4023A6CU
+
+#define Addr_NX4000_intram0         0x05080000U
+#define Addr_NX4000_intram1         0x05090000U
+#define Addr_NX4000_intram2         0x050A0000U
+#define Addr_NX4000_intram3         0x050B0000U
+
+#define REL_Adr_NX4000_ram_end            0x00001FFCU
+
+#define REL_Adr_NX4000_intram_end             0x0000FFFCU
+
+HW_PTR_XC_START_STOP(s_ptXcStartStop)
+
+HW_PTR_RPEC_REGS(s_aptRpecRegArea)
+HW_PTR_RPEC_PRAM_START(s_apulRpecPramArea)
+HW_PTR_RPEC_PRAM_END(s_apulRpecPramAreaEnd)
+
+HW_PTR_TPEC_PRAM_START(s_apulTpecPramArea)
+HW_PTR_TPEC_PRAM_END(s_apulTpecPramAreaEnd)
+
+HW_PTR_TPU_PRAM_START(s_aptTpuPramArea)
+HW_PTR_TPU_PRAM_END(s_aptTpuPramAreaEnd)
+
+HW_PTR_TPEC_REGS(s_aptTpecRegArea)
+
+HW_PTR_XMAC(s_aptXmacArea)
+
+HW_PTR_RPU_PRAM_START(s_aptRpuPramArea)
+HW_PTR_RPU_PRAM_END(s_aptRpuPramAreaEnd)
+
+typedef uint8_t ETHERNET_MAC_ADDR_T[6];
+
+typedef struct NX4000_POINTER_FIFO_AREA_Ttag
+{
+  volatile uint32_t aulPfifo[32];
+  volatile uint32_t aulPfifo_border[32];
+  volatile uint32_t  ulPfifo_reset;
+  volatile uint32_t  ulPfifo_full;
+  volatile uint32_t  ulPfifo_empty;
+  volatile uint32_t  ulPfifo_overflow;
+  volatile uint32_t  ulPfifo_underrun;
+  volatile uint32_t aulReserved2[27];
+  volatile uint32_t aulPfifo_fill_level[32];
+} NX4000_POINTER_FIFO_AREA_T;
+
+#endif
diff --git a/drivers/net/ethernet/netx4000/netx4000-xc.c b/drivers/net/ethernet/netx4000/netx4000-xc.c
new file mode 100644
index 000000000000..020825d15579
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/netx4000-xc.c
@@ -0,0 +1,476 @@
+/*
+* MDIO XC driver for Hilscher netx4000 based platforms
+*
+* drivers/net/ethernet/netx4000-xc.c
+*
+* (C) Copyright 2015 Hilscher Gesellschaft fuer Systemautomation mbH
+* http://www.hilscher.com
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of
+* the License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+*/
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/export.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+
+#include "netx4000-xc.h"
+#include "netx4000-xceth-hal.h"
+
+static DEFINE_MUTEX(xc_lock);
+
+static uint32_t xc_in_use = 0;
+
+//TODO:
+#define Addr_NX4000_xc_start_stop 0xF4023A80U
+
+/* Code to support firmware files provided in DT format */
+/*
+-------------------------------------------------------------------------------------------------------------------------
+|                            xc0                            |                            xc1                            | eXcNo
+-------------------------------------------------------------------------------------------------------------------------
+|            xcPort0          |            xcPort1          |            xcPort0          |            xcPort1          | eXcPortNo
+-------------------------------------------------------------------------------------------------------------------------
+| rpec0 | tpec0 | rpu0 | tpu0 | rpec1 | tpec1 | rpu1 | tpu1 | rpec2 | tpec2 | rpu2 | tpu2 | rpec3 | tpec3 | rpu3 | tpu3 | eXcPortType
+-------------------------------------------------------------------------------------------------------------------------
+*/
+
+typedef enum {
+    XC0 = 0,
+    XC1,
+    XC_MAX
+} eXcNo_t;
+
+typedef enum {
+    XC_PORT0 = 0,
+    XC_PORT1,
+    XC_PORT_MAX
+} eXcPortNo_t;
+
+typedef enum {
+    XC_PORT_TYPE_RPEC = 0,
+    XC_PORT_TYPE_TPEC,
+    XC_PORT_TYPE_RPU,
+    XC_PORT_TYPE_TPU,
+    XC_PORT_TYPE_MAX
+} eXcPortType_t;
+
+struct xcunit {
+    char name[8];
+    eXcNo_t uXcNo;
+    eXcPortNo_t uXcPortNo;
+    eXcPortType_t eXcPortType;
+};
+
+#define for_all_xcs(xc) \
+for (xc=0; xc<XC_MAX; xc++)
+
+#define for_all_xc_ports(xc,port) \
+for_all_xcs(xc) \
+    for (port=0; port<XC_PORT_MAX; port++)
+
+#define for_all_types(type) \
+    for (type=0; type<XC_PORT_TYPE_MAX; type++)
+
+#define for_all_xc_port_types(xc,port,type) \
+for_all_xc_ports(xc,port) \
+    for_all_types(type)
+
+#define xcunit_index(xc,port,type) ((xc*XC_PORT_MAX*XC_PORT_TYPE_MAX) + (port*XC_PORT_TYPE_MAX) + type)
+
+struct xcunit xcunit[] = {
+    { "rpec0", XC0, XC_PORT0, XC_PORT_TYPE_RPEC},
+    { "tpec0", XC0, XC_PORT0, XC_PORT_TYPE_TPEC},
+    { "rpu0",  XC0, XC_PORT0, XC_PORT_TYPE_RPU},
+    { "tpu0",  XC0, XC_PORT0, XC_PORT_TYPE_TPU},
+    { "rpec1", XC0, XC_PORT1, XC_PORT_TYPE_RPEC},
+    { "tpec1", XC0, XC_PORT1, XC_PORT_TYPE_TPEC},
+    { "rpu1",  XC0, XC_PORT1, XC_PORT_TYPE_RPU},
+    { "tpu1",  XC0, XC_PORT1, XC_PORT_TYPE_TPU},
+    { "rpec2", XC1, XC_PORT0, XC_PORT_TYPE_RPEC},
+    { "tpec2", XC1, XC_PORT0, XC_PORT_TYPE_TPEC},
+    { "rpu2",  XC1, XC_PORT0, XC_PORT_TYPE_RPU},
+    { "tpu2",  XC1, XC_PORT0, XC_PORT_TYPE_TPU},
+    { "rpec3", XC1, XC_PORT1, XC_PORT_TYPE_RPEC},
+    { "tpec3", XC1, XC_PORT1, XC_PORT_TYPE_TPEC},
+    { "rpu3",  XC1, XC_PORT1, XC_PORT_TYPE_RPU},
+    { "tpu3",  XC1, XC_PORT1, XC_PORT_TYPE_TPU}
+};
+struct firmware_data {
+	char firmware[16];
+	char version[16];
+	uint32_t *xc_microcode[XC_PORT_TYPE_MAX];
+};
+
+struct fw_info {
+	struct device_node* root;
+	struct firmware* fw;
+};
+
+struct fw_info* get_root_node(struct port* p, char* name, struct fw_info* fw_info)
+{
+	int ret = 0;
+	const struct firmware* fw = NULL;
+	struct device_node* root = NULL;
+
+	if (0 == (ret = request_firmware(&fw, name, p->dev))) {
+		root = of_fdt_unflatten_tree( (unsigned long*)fw->data, p->dev->of_node, &root);
+		if (root == NULL) {
+			dev_err( p->dev, "%s: Failed to interprete firmware!\n", __func__);
+			release_firmware( fw);
+			fw_info = NULL;
+		} else {
+			fw_info->fw = (struct firmware*)fw;
+			fw_info->root = root;
+		}
+	} else {
+		dev_err( p->dev, "%s: Error requesting firmware %d!\n", __func__, ret);
+		fw_info = NULL;
+	}
+	return fw_info;
+}
+
+void free_root_node(struct fw_info* fw_info)
+{
+	release_firmware( fw_info->fw);
+}
+
+static int parse_fw_dtb( struct port* p, struct xc_res* xc, struct firmware_data *fwdata)
+{
+	struct device_node *node;
+	char name[256];
+	int xcinst = xc->xcinst;
+	int xcno = 0;
+	int rc = -EAGAIN;
+	struct fw_info fw;
+	struct device_node* root = NULL;
+	char* xc_name[2];
+
+	snprintf(name, sizeof(name), "%s%d.bin", FIRMWARE_NAME, xcinst);
+
+	if (NULL == get_root_node(p, name, &fw)) {
+		return -ENOENT;
+	}
+	if ((rc = of_property_read_string_array(p->dev->of_node, "xc_res", (const char**)xc_name, p->no_of_xcinst)) > 0) {
+		int index = xcinst;
+		if (index != 0) {
+			index = index % p->no_of_xcinst;
+		}
+		snprintf(name, sizeof(name), "%s", xc_name[index]);
+	} else {
+		dev_err( p->dev, "%s: Failed to read xc res array!\n", __func__);
+		free_root_node( &fw);
+		return -ENOENT;
+	}
+	root = fw.root;
+	node = of_find_node_by_name(root, name);
+	if (node) {
+		struct property *prop;
+		int type = 0;
+		void *pv;
+
+		rc = of_property_read_string(root, "firmware", (const char**)&pv);
+		if (rc) {
+			dev_err( p->dev, "%s: Reading firmware name failed\n", __func__);
+			rc = -ENODATA;
+			goto err_out;
+		}
+		strncpy(fwdata->firmware, pv, sizeof(fwdata->firmware));
+
+		rc = of_property_read_string(root, "version", (const char**)&pv);
+		if (rc) {
+			dev_err( p->dev, "%s: Reading firmware version failed\n", __func__);
+			rc = -ENODATA;
+			goto err_out;
+		}
+		strncpy(fwdata->version, pv, sizeof(fwdata->version));
+
+		for_all_xc_port_types(xcno, xcinst, type) {
+			int i = xcunit_index(xcno, xcinst, type);
+
+			prop = of_find_property(node, xcunit[i].name, NULL);
+			if (!prop)
+				continue;
+
+			fwdata->xc_microcode[type] = kzalloc(max(8 /* program size, trailing loads size */, prop->length), GFP_KERNEL);
+			if (!fwdata->xc_microcode[type]) {
+				dev_err( p->dev, "%s: xzalloc() failed!\n", __func__);
+				rc = -ENOMEM;
+				goto err_out;
+			}
+			rc = of_property_read_u32_array( node, xcunit[i].name, fwdata->xc_microcode[type], prop->length/sizeof(uint32_t));
+			if (IS_ERR((const void*)rc)) {
+				dev_err( p->dev, "%s: Reading microcode failed!\n", __func__);
+				rc = PTR_ERR((const void*)rc);
+				goto err_out;
+			}
+		}
+		rc = 0;
+	} else {
+		dev_err( p->dev, "%s: Parsing firmware failed!\n", __func__);
+	}
+	free_root_node( &fw);
+err_out:
+	return rc;
+}
+
+/*****************************************************************************/
+/* Definitions                                                               */
+/*****************************************************************************/
+
+int port_set_mac_addr( struct port* p, ETH_MAC_ADDRESS_TYPE_E eType, ETHERNET_MAC_ADDR_T tMacAddr)
+{
+	return netx4000_xceth_set_mac_address( p->portno, eType, tMacAddr);
+}
+
+int port_get_mac_addr( struct port* p, ETH_MAC_ADDRESS_TYPE_E eType, ETHERNET_MAC_ADDR_T* ptMacAddr)
+{
+	return netx4000_xceth_get_mac_address( p->portno, eType, ptMacAddr);
+}
+
+int port_set_link_mode( struct port* p, int fValid, unsigned int uiSpeed, int fFdx)
+{
+	return netx4000_xceth_set_link_mode( p->portno, fValid, uiSpeed, fFdx);
+}
+
+
+int port_reset( struct port* p)
+{
+	int ret = 0;
+	int i;
+
+	for (i=0;i<p->no_of_xcinst;i++) {
+		ret = xc_reset( p->xc_res[i]);
+	}
+	return ret;
+}
+
+int port_start( struct port* p)
+{
+	int ret = 0;
+	int i;
+
+	for (i=0;i<p->no_of_xcinst;i++) {
+		ret = xc_start( p->xc_res[i]);
+	}
+	return ret;
+}
+
+int port_stop( struct port* p)
+{
+	int ret = 0;
+	int i;
+
+	for (i=0;i<p->no_of_xcinst;i++) {
+		ret = xc_stop( p->xc_res[i]);
+	}
+	return ret;
+}
+
+int port_request_firmware(struct port *p)
+{
+	int ret = -EINVAL;
+	int xc_res = 0;
+	struct firmware_data fw;
+
+	for (xc_res=0;xc_res<p->no_of_xcinst;xc_res++) {
+		int type = 0;
+
+		dev_dbg( p->dev, "%s: requesting firmware for %d\n", __func__, p->portno);
+		ret = parse_fw_dtb( p, p->xc_res[xc_res], &fw);
+		if (ret < 0) {
+			return ret;
+		}
+		ret = -EINVAL;
+		for_all_types(type) {
+			ret = xc_load(  p->xc_res[xc_res], type, fw.xc_microcode[type]);
+			if (ret < 0) {
+				dev_err(p->dev, "%s: downloading firmware failed for type=%d (ret=%d)\n", __func__, type, ret);
+				return ret;
+			}
+		}
+	}
+	return ret;
+}
+
+void port_confirm_irq( struct port* p, uint32_t mask)
+{
+	int i = 0;
+
+	for (i=0;i<p->no_of_xcinst;i++) {
+		//*p->xc_res[i]->xpec_irqregs->aulIrq_xpec[i] = 0xFFFF & mask;
+		*p->xc_res[i]->xpec_irqregs = 0xFFFF & mask;
+	}
+}
+
+uint32_t port_get_irq( struct port* p)
+{
+	int i = 0;
+	uint32_t flags = 0;
+
+	for (i=0;i<p->no_of_xcinst;i++) {
+		flags |= 0xFFFF & *p->xc_res[i]->xpec_irqregs;
+	}
+	return flags;
+}
+
+int port_set_irq( struct port* p, uint32_t mask)
+{
+	int i = 0;
+
+	for (i=0;i<p->no_of_xcinst;i++) {
+		p->xc_res[i]->xpec_dpm->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_IND_HI = mask & MSK_ETHMAC_INTERRUPTS_ENABLE_IND_HI_VAL;
+		p->xc_res[i]->xpec_dpm->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_IND_LO = mask & MSK_ETHMAC_INTERRUPTS_ENABLE_IND_LO_VAL;
+		p->xc_res[i]->xpec_dpm->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_CON_HI = mask & MSK_ETHMAC_INTERRUPTS_ENABLE_CON_HI_VAL;
+		p->xc_res[i]->xpec_dpm->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_CON_LO = mask & MSK_ETHMAC_INTERRUPTS_ENABLE_CON_LO_VAL;
+		p->xc_res[i]->xpec_dpm->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED = mask & MSK_ETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED_VAL;
+		p->xc_res[i]->xpec_dpm->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_COL = mask & MSK_ETHMAC_INTERRUPTS_ENABLE_COL_VAL;
+		p->xc_res[i]->xpec_dpm->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_EARLY_RCV = mask & MSK_ETHMAC_INTERRUPTS_ENABLE_EARLY_RCV_VAL;
+		p->xc_res[i]->xpec_dpm->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_RX_ERR = mask & MSK_ETHMAC_INTERRUPTS_ENABLE_RX_ERR_VAL;
+		p->xc_res[i]->xpec_dpm->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_TX_ERR = mask & MSK_ETHMAC_INTERRUPTS_ENABLE_TX_ERR_VAL;
+	}
+	return 0;
+}
+
+struct port *port_request( uint8_t port, struct device *dev)
+{
+	struct port *p = NULL;
+	int xcinst = 0;
+	int offset;
+	int ret = -EAGAIN;
+
+	dev_dbg( dev, "%s: requesting port %d\n", __func__, port);
+
+	mutex_lock(&xc_lock);
+
+	if (xc_in_use & (1 << port))
+		goto exit;
+
+	p = kzalloc(sizeof (struct port), GFP_KERNEL);
+	if (!p)
+		goto exit;
+
+	if ( (p->no_of_xcinst = of_property_read_string_array(dev->of_node, "xc_res", NULL, 2)) > 0) {
+		ret = 0;
+		p->portno = port;
+		offset = (p->portno * p->no_of_xcinst);
+		for (xcinst = 0; xcinst < p->no_of_xcinst; xcinst++) {
+			xc_units_enable( offset + xcinst);
+			if ((p->xc_res[xcinst] = xc_alloc_xc_res(dev, offset + xcinst)) == NULL) {
+				dev_err( p->dev, "%s: Failed to allocate xc resources!\n", __func__);
+				ret = -EINVAL;
+			}
+		}
+		if (ret == 0) {
+			p->dev = dev;
+			port_reset(p);
+			if ((ret = port_request_firmware( p)) == 0)
+				xc_in_use |= (1 << p->portno);
+		}
+		if (ret != 0) {
+			for (xcinst = 0; xcinst < p->no_of_xcinst; xcinst++) {
+				if (p->xc_res[xcinst] != NULL)
+					xc_release_xc_res(p->xc_res[xcinst]);
+				p->xc_res[xcinst] = NULL;
+			}
+		}
+	}
+	if (ret != 0) {
+		dev_err( dev, "%s: Failed to initialize xc resources!\n", __func__);
+		kfree(p);
+		p = NULL;
+	}
+exit:
+	mutex_unlock(&xc_lock);
+	return p;
+}
+
+void port_free(struct port* p)
+{
+	int i = 0;
+
+	mutex_lock(&xc_lock);
+	if (xc_in_use & (1 << p->portno)) {
+		xc_in_use &= ~(1 << p->portno);
+		for (i=0;i<p->no_of_xcinst;i++) {
+			int xcinst = p->xc_res[i]->xcinst;
+			xc_release_xc_res( p->xc_res[i]);
+			xc_units_disable( xcinst);
+		}
+		kfree(p);
+	}
+	mutex_unlock(&xc_lock);
+}
+
+#define ASIC_CTRL_ACCESS_KEY 0xf408017c
+
+/* misc clock is set by phy driver */
+#define XPIC_CLOCK(port) (0x20000<<port)
+#define XMAC_CLOCK(port) (0x00100<<port)
+#define TPEC_CLOCK(port) (0x00010<<port)
+#define RPEC_CLOCK(port) (0x00001<<port)
+
+#define XC_PORT_CLOCK(port) (XPIC_CLOCK(port)|XMAC_CLOCK(port)|TPEC_CLOCK(port)|RPEC_CLOCK(port))
+
+void xc_units_enable( uint8_t xcinst) {
+
+	if ((xc_in_use & (1 << xcinst)) == 0) {
+		/* enable clocks */
+		volatile uint32_t* clock = ioremap(0xf4080138, sizeof(uint32_t));
+		volatile uint32_t* key_addr = ioremap(ASIC_CTRL_ACCESS_KEY, sizeof(key_addr));
+		if (clock != NULL) {
+			uint32_t val = ioread32(clock);
+			uint32_t keyval = ioread32(key_addr);
+			iowrite32(keyval, key_addr);
+			writel((val|XC_PORT_CLOCK(xcinst)), clock);
+			iounmap(key_addr);
+			iounmap(clock);
+		}
+	}
+}
+
+void xc_units_disable(uint8_t xcinst) {
+	if ((xc_in_use & (1 << xcinst)) == 0) {
+		/* disable clocks */
+		volatile uint32_t* clock = ioremap(0xf4080138, sizeof(uint32_t));
+		volatile uint32_t* key_addr = ioremap(ASIC_CTRL_ACCESS_KEY, sizeof(key_addr));
+		if (clock != NULL) {
+			uint32_t val = ioread32(clock);
+			uint32_t keyval = ioread32(key_addr);
+			iowrite32(keyval, key_addr);
+			writel((val&~XC_PORT_CLOCK(xcinst)), clock);
+			iounmap(key_addr);
+			iounmap(clock);
+		}
+	}
+}
+
+EXPORT_SYMBOL(port_free);
+EXPORT_SYMBOL(port_request);
+EXPORT_SYMBOL(port_request_firmware);
+EXPORT_SYMBOL(port_reset);
+EXPORT_SYMBOL(port_set_irq);
+EXPORT_SYMBOL(port_get_irq);
+EXPORT_SYMBOL(port_confirm_irq);
+EXPORT_SYMBOL(port_start);
+EXPORT_SYMBOL(port_stop);
+EXPORT_SYMBOL(port_set_link_mode);
+EXPORT_SYMBOL(port_get_mac_addr);
+EXPORT_SYMBOL(port_set_mac_addr);
diff --git a/drivers/net/ethernet/netx4000/netx4000-xc.h b/drivers/net/ethernet/netx4000/netx4000-xc.h
new file mode 100644
index 000000000000..a725e01e3402
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/netx4000-xc.h
@@ -0,0 +1,38 @@
+
+#ifndef NETX4000_XC_H
+#define NETX4000_XC_H
+
+#define FIRMWARE_NAME "hethmac-xc"
+
+#include "netx4000-xc-hal.h"
+#include "netx4000-xceth-hal.h"
+
+struct port {
+	struct device* dev;
+
+	uint8_t portno;
+	uint8_t no_of_xcinst;
+	struct xc_res* xc_res[2];
+
+	//NX4000_POINTER_FIFO_AREA_T* ptPFifo;
+	//uint32_t pfifo_offset; /* FIFO_CHANNELS_PER_UNIT... */
+
+	struct device_node *devnode;
+};
+
+void xc_units_enable(uint8_t port);
+void xc_units_disable(uint8_t port);
+struct port *port_request( uint8_t port, struct device *dev);
+void port_free(struct port* portno);
+int port_start(struct port* portno);
+int port_stop(struct port* portno);
+int port_reset(struct port* portno);
+int port_request_firmware(struct port* portno);
+int port_set_irq(struct port* portno, uint32_t mask);
+uint32_t port_get_irq(struct port* port);
+void port_confirm_irq(struct port* port, uint32_t mask);
+int port_set_link_mode( struct port* p, int fValid, unsigned int uiSpeed, int fFdx);
+int port_set_mac_addr( struct port* p, ETH_MAC_ADDRESS_TYPE_E eType, ETHERNET_MAC_ADDR_T tMacAddr);
+int port_get_mac_addr( struct port* p, ETH_MAC_ADDRESS_TYPE_E eType, ETHERNET_MAC_ADDR_T* ptMacAddr);
+
+#endif
diff --git a/drivers/net/ethernet/netx4000/netx4000-xceth-hal.c b/drivers/net/ethernet/netx4000/netx4000-xceth-hal.c
new file mode 100644
index 000000000000..de42052df060
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/netx4000-xceth-hal.c
@@ -0,0 +1,914 @@
+/*
+* XC Ethernet HAL functions for Hilscher netX4000 based platforms
+*
+* drivers/net/netx4000-xceth-hal.c
+*
+* (C) Copyright 2014 Hilscher Gesellschaft fuer Systemautomation mbH
+* http://www.hilscher.com
+*
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; version 2 of
+* the License.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+*/
+
+#ifdef __BAREBOX_CODE
+// 	#warning "BAREBOX_CODE"
+	#include <common.h>
+	#include <init.h>
+
+	#include <mach/regdef_netx4000.h>
+	#include "netx4000-xceth-hal.h"
+
+	/* Remove comment tags below for using linux code */
+// 	#define request_mem_region(start,n,name)   request_iomem_region(name, start, start+n-1)
+// 	#define release_region(start,n)            release_region(start)
+// 	#define ioremap(res_cookie,size)           IOMEM(res_cookie)
+
+#else
+// 	#warning "LINUX_CODE"
+	#include <linux/device.h>
+	#include <linux/slab.h>
+	#include <linux/io.h>
+	#include <linux/ioport.h>
+
+	#include "netx4000-xc-res.h"
+	#include "netx4000-xceth-hal.h"
+#endif
+
+#define __ETHMAC_DISABLE_CHECKS__  1
+
+/******************************************************************************/
+/* Definitions                                                                */
+/******************************************************************************/
+
+#define ETHMAC_PORTS  4
+
+#define ETHERNET_MINIMUM_FRAMELENGTH                    60
+#define ETHERNET_MAXIMUM_FRAMELENGTH                    1518
+
+#define NUM_FIFO_CHANNELS_PER_UNIT                      16      /**< Number of FIFO units per XC channel */
+#define FIFO_ENTRIES                                    100     /**< FIFO depth for each of the 8 FIFOs  */
+#define ETH_FRAME_BUF_SIZE                              1560    /**< size of a frame buffer              */
+#define INTRAM_SEGMENT_SIZE                             0x10000 /**< size of the internal ram segments   */
+
+#define ETHERNET_FIFO_EMPTY                             0      /**< Empty pointer FIFO               */
+#define ETHERNET_FIFO_IND_HI                            1      /**< High priority indication FIFO    */
+#define ETHERNET_FIFO_IND_LO                            2      /**< Low priority indication FIFO     */
+#define ETHERNET_FIFO_REQ_HI                            3      /**< High priority request FIFO       */
+#define ETHERNET_FIFO_REQ_LO                            4      /**< Low priority request FIFO        */
+#define ETHERNET_FIFO_CON_HI                            5      /**< High priority confirmation FIFO  */
+#define ETHERNET_FIFO_CON_LO                            6      /**< Low priority confirmation FIFO   */
+
+/* confirmation error codes */
+#define CONF_ERRCODE_TX_SUCCESSFUL_WITHOUT_RETRIES      0x0    /**< Confirmation: Success on first try   */
+#define CONF_ERRCODE_TX_SUCCESSFUL_WITH_RETRIES         0x1    /**< Confirmation: Success after some retries */
+#define CONF_ERRCODE_TX_FAILED_LATE_COLLISION           0x8    /**< Confirmation: Error late collision */
+#define CONF_ERRCODE_TX_FAILED_LINK_DOWN_DURING_TX      0x9    /**< Confirmation: Error link down      */
+#define CONF_ERRCODE_TX_FAILED_EXCESSIVE_COLLISION      0xa    /**< Confirmation: Error collision      */
+#define CONF_ERRCODE_TX_FAILED_UTX_UFL_DURING_TX        0xb    /**< Confirmation: Error FIFO overflow  */
+#define CONF_ERRCODE_TX_FAILED_FATAL_ERROR              0xc    /**< Confirmation: Error Fatal          */
+
+#define PFIFO_INST_CNT  2
+
+/******************************************************************************/
+/* Address arrays                                                             */
+/******************************************************************************/
+
+static uint32_t* const _s_apulXpecDramArea[] = {
+	(uint32_t*) Adr_NX4000_xc0_tpec0_dram_ram_start,
+	(uint32_t*) Adr_NX4000_xc0_tpec1_dram_ram_start,
+	(uint32_t*) Adr_NX4000_xc1_tpec0_dram_ram_start,
+	(uint32_t*) Adr_NX4000_xc1_tpec1_dram_ram_start
+};
+#define XPEC_RAM_SIZE (REL_Adr_NX4000_ram_end+sizeof(uint32_t))
+
+static uint32_t* const _s_ptXpecIrqRegs[] = {
+	(uint32_t*)  Adr_NX4000_xc0_irq_xpec0,
+	(uint32_t*)  Adr_NX4000_xc0_irq_xpec1,
+	(uint32_t*)  Adr_NX4000_xc1_irq_xpec0,
+	(uint32_t*)  Adr_NX4000_xc1_irq_xpec1
+};
+
+static NX4000_POINTER_FIFO_AREA_T* const _s_aptPFifo[] = {
+	(NX4000_POINTER_FIFO_AREA_T*) Addr_NX4000_xc0_pointer_fifo,
+	(NX4000_POINTER_FIFO_AREA_T*) Addr_NX4000_xc1_pointer_fifo
+};
+
+static uint32_t* const _s_apulIntRamStart[] = {
+	(uint32_t*) Addr_NX4000_intram0,
+	(uint32_t*) Addr_NX4000_intram1,
+	(uint32_t*) Addr_NX4000_intram2,
+	(uint32_t*) Addr_NX4000_intram3
+};
+#define INTRAM_SIZE (REL_Adr_NX4000_intram_end+sizeof(uint32_t))
+
+/******************************************************************************/
+/* Global variables                                                           */
+/******************************************************************************/
+
+struct resource *XpecDRam_res[ETHMAC_PORTS] = {NULL};
+struct resource *XpecIrqRegs_res[4] = {NULL};
+struct resource *PFifo_res[PFIFO_INST_CNT] = {NULL};
+struct resource *IntRamStart_res[4] = {NULL};
+
+static volatile ETHMAC_XPEC_DPM* s_aptXpecDRam[ETHMAC_PORTS];
+static volatile uint32_t* s_ptXpecIrqRegs[ETHMAC_PORTS];
+static volatile NX4000_POINTER_FIFO_AREA_T* s_aptPFifo[PFIFO_INST_CNT];
+static volatile uint32_t* s_apulIntRamStart[4];
+
+struct fifo_res *g_fifoRes[ETHMAC_PORTS] = {NULL};
+
+static uint32_t refcount_bitfield = 0;
+
+/******************************************************************************/
+/* HAL function code                                                          */
+/******************************************************************************/
+
+void netx4000_pfifo_reset(uint8_t xcNo)
+{
+	unsigned int uCnt;
+
+	if (xcNo < PFIFO_INST_CNT) {
+		/* set reset flag of all fifos */
+		iowrite32(0xffffffff, &s_aptPFifo[xcNo]->ulPfifo_reset);
+
+		/* reset pointer fifo borders */
+		for(uCnt = 0; uCnt < 32; uCnt++) {
+			iowrite32(((uCnt+1)* 100)-1, &s_aptPFifo[xcNo]->aulPfifo_border[uCnt]) ;
+		}
+
+		/* clear reset flag of all fifos */
+		iowrite32(0, &s_aptPFifo[xcNo]->ulPfifo_reset);
+	}
+}
+
+#ifdef __BAREBOX_CODE
+
+static int netx4000_xceth_release_fifo_res(struct fifo_res *fifoRes)
+{
+	uint8_t xcinst = fifoRes->xcinst;
+	uint8_t xcNo   = fifoRes->xcNo;
+// 	uint8_t xcPortNo = fifoRes->xcPortNo;
+
+	if (XpecDRam_res[xcinst]) {
+		release_region(XpecDRam_res[xcinst]);
+		XpecDRam_res[xcinst] = NULL;
+	}
+	if (XpecIrqRegs_res[xcinst]) {
+		release_region(XpecIrqRegs_res[xcinst]);
+		XpecIrqRegs_res[xcinst] = NULL;
+	}
+
+	refcount_bitfield &= ~(1<<xcinst);
+
+	if ((refcount_bitfield & (0x3<<xcNo)) == 0) {
+		if (PFifo_res[xcNo]) {
+			release_region(PFifo_res[xcNo]);
+			PFifo_res[xcNo] = NULL;
+		}
+	}
+	if (refcount_bitfield == 0) {
+		if (IntRamStart_res[0]) {
+			release_region(IntRamStart_res[0]);
+			IntRamStart_res[0] = NULL;
+		}
+		if (IntRamStart_res[1]) {
+			release_region(IntRamStart_res[1]);
+			IntRamStart_res[1] = NULL;
+		}
+		if (IntRamStart_res[2]) {
+			release_region(IntRamStart_res[2]);
+			IntRamStart_res[2] = NULL;
+		}
+		if (IntRamStart_res[3]) {
+			release_region(IntRamStart_res[3]);
+			IntRamStart_res[3] = NULL;
+		}
+	}
+
+	free(fifoRes);
+
+	return 0;
+}
+
+static struct fifo_res *netx4000_xceth_alloc_fifo_res(struct device_d *dev, uint8_t xcinst)
+{
+	struct fifo_res *fifoRes;
+	struct resource *res;
+	uint8_t xcNo   = xcinst >> 1;
+	uint8_t xcPortNo = xcinst & 1;
+
+	fifoRes = xzalloc(sizeof(*fifoRes));
+	if (!fifoRes)
+		return NULL;
+
+	fifoRes->xcinst = xcinst;
+	fifoRes->xcNo = xcNo;
+	fifoRes->xcPortNo = xcPortNo;
+
+	do {
+		res = request_iomem_region(dev_name(dev), (resource_size_t)_s_apulXpecDramArea[xcinst], (resource_size_t)_s_apulXpecDramArea[xcinst]+XPEC_RAM_SIZE-1);
+		if (IS_ERR(res))
+			break;
+		XpecDRam_res[xcinst] = res;
+
+		res = request_iomem_region(dev_name(dev), (resource_size_t)_s_ptXpecIrqRegs[xcinst], (resource_size_t)(_s_ptXpecIrqRegs[xcinst]+1)-1);
+		if (IS_ERR(res))
+			break;
+		XpecIrqRegs_res[xcinst] = res;
+
+		if ((refcount_bitfield & (0x3<<xcNo)) == 0) {
+			res = request_iomem_region(dev_name(dev), (resource_size_t)_s_aptPFifo[xcNo], (resource_size_t)(_s_aptPFifo[xcNo]+1)-1);
+			if (IS_ERR(res))
+				break;
+			PFifo_res[xcNo] = res;
+		}
+
+		if (refcount_bitfield == 0) {
+			res = request_iomem_region(dev_name(dev), (resource_size_t)_s_apulIntRamStart[0], (resource_size_t)_s_apulIntRamStart[0]+INTRAM_SIZE-1);
+			if (IS_ERR(res))
+				break;
+			IntRamStart_res[0] = res;
+
+			res = request_iomem_region(dev_name(dev), (resource_size_t)_s_apulIntRamStart[1], (resource_size_t)_s_apulIntRamStart[1]+INTRAM_SIZE-1);
+			if (IS_ERR(res))
+				break;
+			IntRamStart_res[1] = res;
+
+			res = request_iomem_region(dev_name(dev), (resource_size_t)_s_apulIntRamStart[2], (resource_size_t)_s_apulIntRamStart[2]+INTRAM_SIZE-1);
+			if (IS_ERR(res))
+				break;
+			IntRamStart_res[2] = res;
+
+			res = request_iomem_region(dev_name(dev), (resource_size_t)_s_apulIntRamStart[3], (resource_size_t)_s_apulIntRamStart[3]+INTRAM_SIZE-1);
+			if (IS_ERR(res))
+				break;
+			IntRamStart_res[3] = res;
+		}
+
+		refcount_bitfield |= (1<<xcinst);
+	} while (0);
+
+	if (IS_ERR(res))
+		goto err_out;
+
+	s_aptXpecDRam[xcinst] = IOMEM(XpecDRam_res[xcinst]->start);
+	s_ptXpecIrqRegs[xcinst] = IOMEM(XpecIrqRegs_res[xcinst]->start);
+	s_aptPFifo[xcNo] = IOMEM(PFifo_res[xcNo]->start);
+	s_apulIntRamStart[0] = IOMEM(IntRamStart_res[0]->start);
+	s_apulIntRamStart[1] = IOMEM(IntRamStart_res[1]->start);
+	s_apulIntRamStart[2] = IOMEM(IntRamStart_res[2]->start);
+	s_apulIntRamStart[3] = IOMEM(IntRamStart_res[3]->start);
+
+	return fifoRes;
+
+err_out:
+	netx4000_xceth_release_fifo_res(fifoRes);
+
+	return NULL;
+}
+
+#else /* __BAREBOX_CODE */
+
+static int netx4000_xceth_release_fifo_res(struct fifo_res *fifoRes)
+{
+	uint8_t xcinst = fifoRes->xcinst;
+	uint8_t xcNo   = fifoRes->xcNo;
+// 	uint8_t xcPortNo = fifoRes->xcPortNo;
+
+	if (XpecDRam_res[xcinst]) {
+		release_mem_region(XpecDRam_res[xcinst]->start, resource_size(XpecDRam_res[xcinst]));
+		XpecDRam_res[xcinst] = NULL;
+	}
+	if (XpecIrqRegs_res[xcinst]) {
+		release_mem_region(XpecIrqRegs_res[xcinst]->start, resource_size(XpecIrqRegs_res[xcinst]));
+		XpecIrqRegs_res[xcinst] = NULL;
+	}
+
+	refcount_bitfield &= ~(1<<xcinst);
+
+	if ((refcount_bitfield & (0x3<<xcNo)) == 0) {
+		if (PFifo_res[xcNo]) {
+			release_mem_region(PFifo_res[xcNo]->start, resource_size(PFifo_res[xcNo]));
+			PFifo_res[xcNo] = NULL;
+		}
+	}
+	if (refcount_bitfield == 0) {
+		if (IntRamStart_res[0]) {
+			release_mem_region(IntRamStart_res[0]->start, resource_size(IntRamStart_res[0]));
+			IntRamStart_res[0] = NULL;
+		}
+		if (IntRamStart_res[1]) {
+			release_mem_region(IntRamStart_res[1]->start, resource_size(IntRamStart_res[1]));
+			IntRamStart_res[1] = NULL;
+		}
+		if (IntRamStart_res[2]) {
+			release_mem_region(IntRamStart_res[2]->start, resource_size(IntRamStart_res[2]));
+			IntRamStart_res[2] = NULL;
+		}
+		if (IntRamStart_res[3]) {
+			release_mem_region(IntRamStart_res[3]->start, resource_size(IntRamStart_res[3]));
+			IntRamStart_res[3] = NULL;
+		}
+	}
+
+	kfree(fifoRes);
+
+	return 0;
+}
+
+static struct fifo_res *netx4000_xceth_alloc_fifo_res(struct device *dev, uint8_t xcinst)
+{
+	struct fifo_res *fifoRes;
+	struct resource *res;
+	uint8_t xcNo   = xcinst >> 1;
+	uint8_t xcPortNo = xcinst & 1;
+
+	fifoRes = kzalloc(sizeof(*fifoRes), GFP_KERNEL);
+	if (!fifoRes)
+		return NULL;
+
+	fifoRes->xcinst = xcinst;
+	fifoRes->xcNo = xcNo;
+	fifoRes->xcPortNo = xcPortNo;
+
+	do {
+		res = request_mem_region((resource_size_t)_s_apulXpecDramArea[xcinst], (resource_size_t)XPEC_RAM_SIZE, dev_name(dev));
+		if (res == NULL)
+			break;
+		XpecDRam_res[xcinst] = res;
+
+		res = request_mem_region((resource_size_t)_s_ptXpecIrqRegs[xcinst], (resource_size_t)sizeof(*_s_ptXpecIrqRegs[xcinst]), dev_name(dev));
+		if (res == NULL)
+			break;
+		XpecIrqRegs_res[xcinst] = res;
+
+		if ((refcount_bitfield & (0x3<<xcNo)) == 0) {
+			res = request_mem_region((resource_size_t)_s_aptPFifo[xcNo], (resource_size_t)sizeof(*_s_aptPFifo[xcNo]), dev_name(dev));
+			if (res == NULL)
+				break;
+			PFifo_res[xcNo] = res;
+		}
+
+		if (refcount_bitfield == 0) {
+			res = request_mem_region((resource_size_t)_s_apulIntRamStart[0], (resource_size_t)INTRAM_SIZE, dev_name(dev));
+			if (res == NULL)
+				break;
+			IntRamStart_res[0] = res;
+
+			res = request_mem_region((resource_size_t)_s_apulIntRamStart[1], (resource_size_t)INTRAM_SIZE, dev_name(dev));
+			if (res == NULL)
+				break;
+			IntRamStart_res[1] = res;
+
+			res = request_mem_region((resource_size_t)_s_apulIntRamStart[2], (resource_size_t)INTRAM_SIZE, dev_name(dev));
+			if (res == NULL)
+				break;
+			IntRamStart_res[2] = res;
+
+			res = request_mem_region((resource_size_t)_s_apulIntRamStart[3], (resource_size_t)INTRAM_SIZE, dev_name(dev));
+			if (res == NULL)
+				break;
+			IntRamStart_res[3] = res;
+		}
+
+		refcount_bitfield |= (1<<xcinst);
+	} while (0);
+
+	if (res == NULL)
+		goto err_out;
+
+	s_aptXpecDRam[xcinst] = ioremap(XpecDRam_res[xcinst]->start, resource_size(XpecDRam_res[xcinst]));
+	s_ptXpecIrqRegs[xcinst] = ioremap(XpecIrqRegs_res[xcinst]->start, resource_size(XpecIrqRegs_res[xcinst]));
+	s_aptPFifo[xcNo] = ioremap(PFifo_res[xcNo]->start, resource_size(PFifo_res[xcNo]));
+	s_apulIntRamStart[0] = ioremap(IntRamStart_res[0]->start, resource_size(IntRamStart_res[0]));
+	s_apulIntRamStart[1] = ioremap(IntRamStart_res[1]->start, resource_size(IntRamStart_res[1]));
+	s_apulIntRamStart[2] = ioremap(IntRamStart_res[2]->start, resource_size(IntRamStart_res[2]));
+	s_apulIntRamStart[3] = ioremap(IntRamStart_res[3]->start, resource_size(IntRamStart_res[3]));
+
+	return fifoRes;
+
+err_out:
+	netx4000_xceth_release_fifo_res(fifoRes);
+
+	return NULL;
+}
+
+void netx4000_xceth_confirm_irq( uint8_t port, uint32_t mask)
+{
+	iowrite32(mask & 0xFFFF, s_ptXpecIrqRegs[port]);
+}
+
+uint32_t netx4000_xceth_get_irq( uint8_t port)
+{
+	return (ioread32(s_ptXpecIrqRegs[port]) & 0xFFFF);
+}
+
+int netx4000_xceth_set_irq( uint8_t uiPort, uint32_t mask)
+{
+	iowrite32(mask & MSK_ETHMAC_INTERRUPTS_ENABLE_IND_HI_VAL, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_IND_HI);
+	iowrite32(mask & MSK_ETHMAC_INTERRUPTS_ENABLE_IND_LO_VAL, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_IND_LO);
+	iowrite32(mask & MSK_ETHMAC_INTERRUPTS_ENABLE_CON_HI_VAL, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_CON_HI);
+	iowrite32(mask & MSK_ETHMAC_INTERRUPTS_ENABLE_CON_LO_VAL, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_CON_LO);
+	iowrite32(mask & MSK_ETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED_VAL, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_LINK_CHANGED);
+	iowrite32(mask & MSK_ETHMAC_INTERRUPTS_ENABLE_COL_VAL, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_COL);
+	iowrite32(mask & MSK_ETHMAC_INTERRUPTS_ENABLE_EARLY_RCV_VAL, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_EARLY_RCV);
+	iowrite32(mask & MSK_ETHMAC_INTERRUPTS_ENABLE_RX_ERR_VAL, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_RX_ERR);
+	iowrite32(mask & MSK_ETHMAC_INTERRUPTS_ENABLE_TX_ERR_VAL, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERRUPTS_ENABLE_TX_ERR);
+
+	return 0;
+}
+
+#endif /* __BAREBOX_CODE */
+
+int netx4000_xceth_fifo_release(uint8_t xcinst)
+{
+
+	if (!g_fifoRes[xcinst])
+		return -EINVAL;
+
+	netx4000_xceth_release_fifo_res(g_fifoRes[xcinst]);
+	g_fifoRes[xcinst] = NULL;
+
+	return 0;
+}
+
+#ifdef __BAREBOX_CODE
+int netx4000_xceth_fifo_request(struct device_d *dev, uint8_t xcinst)
+#else
+int netx4000_xceth_fifo_request(struct device *dev, uint8_t xcinst)
+#endif
+{
+	struct fifo_res *res;
+
+	res = netx4000_xceth_alloc_fifo_res(dev, xcinst);
+	if(!res)
+		return -EINVAL;
+
+	g_fifoRes[xcinst] = res;
+
+	return 0;
+}
+
+/* Configuration */
+
+/* Initialize FIFO Unit */
+void netx4000_xceth_initFifoUnit(unsigned int uiPort)
+{
+	uint32_t     ulFifoPtr = 0;
+	unsigned int uiFifoStart;
+	unsigned int uiFifoEnd;
+	unsigned int uiIdx;
+	unsigned int uiEmptyPtrCnt;
+	uint32_t     ulFifoMsk;
+	unsigned int uiXc   = uiPort >> 1;
+	unsigned int uiXpec = uiPort & 1;
+
+	ulFifoMsk = (1UL << NUM_FIFO_CHANNELS_PER_UNIT) - 1;
+	ulFifoMsk = ulFifoMsk << (NUM_FIFO_CHANNELS_PER_UNIT * uiXpec);
+
+	/* set reset bit for all pointer FIFOs */
+	iowrite32(ioread32(&s_aptPFifo[uiXc]->ulPfifo_reset) | ulFifoMsk, &s_aptPFifo[uiXc]->ulPfifo_reset);
+
+	/* get FIFO start and end number of this port number */
+	uiFifoStart = uiXpec * NUM_FIFO_CHANNELS_PER_UNIT;
+	uiFifoEnd = uiFifoStart + NUM_FIFO_CHANNELS_PER_UNIT;
+
+	for(uiIdx = uiFifoStart; uiIdx < uiFifoEnd; uiIdx++) {
+		iowrite32((uiIdx * FIFO_ENTRIES) + FIFO_ENTRIES - 1, &s_aptPFifo[uiXc]->aulPfifo_border[uiIdx]);
+	}
+
+	/* clear reset bit for all pointer FIFO */
+	iowrite32(ioread32(&s_aptPFifo[uiXc]->ulPfifo_reset) & ~ulFifoMsk, &s_aptPFifo[uiXc]->ulPfifo_reset);
+
+	/*** fill empty pointer FIFO ***/
+
+	/* first DWORD in segment 0 is hard wired + IRQ vectors, so it cannot be used */
+	uiEmptyPtrCnt = (INTRAM_SEGMENT_SIZE / ETH_FRAME_BUF_SIZE) - 1;
+
+	/* each port has it's own internal ram bank */
+	ulFifoPtr |= (uiPort << SRT_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM);
+
+	/* fill the empty pointer FIFO */
+	for(uiIdx = 1; uiIdx <= uiEmptyPtrCnt; uiIdx++) {
+		ulFifoPtr &= ~MSK_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM;
+		ulFifoPtr |= (uiIdx << SRT_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM);
+		iowrite32(ulFifoPtr, &s_aptPFifo[uiXc]->aulPfifo[uiFifoStart + ETHERNET_FIFO_EMPTY]);
+	}
+}
+
+int netx4000_xceth_set_link_mode(unsigned int uiPort, bool fValid, unsigned int uiSpeed, bool fFdx)
+{
+	uint32_t ulVal = 0; /* default: invalid link and SPEED10 and HDX */
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if (uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+
+	/* check speed */
+	if ((uiSpeed != 10) && (uiSpeed != 100))
+		return -EINVAL;
+#endif
+
+	if (fValid) {
+		/* link valid: set speed and duplex */
+		if (fValid) ulVal |= MSK_ETHMAC_ARM2XPEC_INTERRUPTS_VALID;
+		if (uiSpeed == 100) ulVal |= MSK_ETHMAC_ARM2XPEC_INTERRUPTS_SPEED100;
+		if (fFdx) ulVal |= MSK_ETHMAC_ARM2XPEC_INTERRUPTS_FDX;
+	}
+
+// 	/* set request */
+// 	s_ptXpecIrqRegs->aulIrq_xpec[uiPort] = MSK_ETHMAC_ARM2XPEC_INTERRUPTS_LINK_MODE_UPDATE_REQ | ulVal;
+//
+// 	/* wait for xPEC confirmed request */
+// 	while(s_ptXpecIrqRegs->aulIrq_xpec[uiPort] & MSK_ETHMAC_ARM2XPEC_INTERRUPTS_LINK_MODE_UPDATE_REQ) {
+// 	  /* FIXME */
+// 	}
+	/* set request */
+	iowrite32(MSK_ETHMAC_ARM2XPEC_INTERRUPTS_LINK_MODE_UPDATE_REQ | ulVal, s_ptXpecIrqRegs[uiPort]);
+
+	/* wait for xPEC confirmed request */
+	while(ioread32(s_ptXpecIrqRegs[uiPort]) & MSK_ETHMAC_ARM2XPEC_INTERRUPTS_LINK_MODE_UPDATE_REQ) {
+	  /* FIXME */
+	}
+  return 0;
+}
+
+int netx4000_xceth_set_mac_address(uint32_t uiPort, ETH_MAC_ADDRESS_TYPE_E eType, ETHERNET_MAC_ADDR_T tMacAddr)
+{
+	uint32_t ulMacHi, ulMacLo;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if (uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+#endif
+
+	ulMacHi = (uint32_t)(tMacAddr[5] << 8)  | (uint32_t)tMacAddr[4];
+	ulMacLo = (uint32_t)(tMacAddr[3] << 24) | (uint32_t)(tMacAddr[2]  << 16) | (uint32_t)(tMacAddr[1]  << 8) | (uint32_t)tMacAddr[0];
+
+	switch(eType) {
+	case ETH_MAC_ADDRESS_CHASSIS:
+		iowrite32(ulMacHi, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERFACE_MAC_ADDRESS_HI);
+		iowrite32(ulMacLo, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERFACE_MAC_ADDRESS_LO);
+		break;
+	case ETH_MAC_ADDRESS_2ND_CHASSIS:
+		iowrite32(ulMacHi, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_2ND_INTERFACE_MAC_ADDRESS_HI);
+		iowrite32(ulMacLo, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_2ND_INTERFACE_MAC_ADDRESS_LO);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int netx4000_xceth_get_mac_address(uint32_t uiPort, ETH_MAC_ADDRESS_TYPE_E eType, ETHERNET_MAC_ADDR_T* ptMacAddr)
+{
+	uint32_t ulTempLo, ulTempHi;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	if (uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+#endif
+
+	switch(eType) {
+	case ETH_MAC_ADDRESS_CHASSIS:
+		ulTempLo = ioread32(&s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERFACE_MAC_ADDRESS_LO);
+		ulTempHi = ioread32(&s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_INTERFACE_MAC_ADDRESS_HI);
+		break;
+	case ETH_MAC_ADDRESS_2ND_CHASSIS:
+		ulTempLo = ioread32(&s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_2ND_INTERFACE_MAC_ADDRESS_LO);
+		ulTempHi = ioread32(&s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_2ND_INTERFACE_MAC_ADDRESS_HI);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	(*ptMacAddr)[0] = (uint8_t)ulTempLo;
+	(*ptMacAddr)[1] = (uint8_t)(ulTempLo >> 8);
+	(*ptMacAddr)[2] = (uint8_t)(ulTempLo >> 16);
+	(*ptMacAddr)[3] = (uint8_t)(ulTempLo >> 24);
+	(*ptMacAddr)[4] = (uint8_t)ulTempHi;
+	(*ptMacAddr)[5] = (uint8_t)(ulTempHi >> 8);
+
+	return 0;
+}
+
+/* TX */
+
+int netx4000_xceth_get_frame(unsigned int uiPort, ETHERNET_FRAME_T** pptFrame, void** phFrame)
+{
+	uint32_t     ulFifoPtr = 0;
+	unsigned int uiRamSegment;
+	unsigned int uiFrameIdx;
+	unsigned int uiFifo;
+	unsigned int uiXc   = uiPort >> 1;
+	unsigned int uiXpec = uiPort & 1;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if (uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+#endif
+
+	/* get FIFO fill level and check if there is at least one element */
+	uiFifo = NUM_FIFO_CHANNELS_PER_UNIT * uiXpec + ETHERNET_FIFO_EMPTY;
+
+	/* keep at least one pointer for the XC level (two parties share this empty pointer FIFO) */
+	if (ioread32(&s_aptPFifo[uiXc]->aulPfifo_fill_level[uiFifo]) < 2)
+		return -EBUSY;
+
+	/* retrieve the FIFO element */
+	ulFifoPtr = ioread32(&s_aptPFifo[uiXc]->aulPfifo[uiFifo]);
+
+	/* extract RAM bank and frame number */
+	uiFrameIdx   = (ulFifoPtr & MSK_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM) >> SRT_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM;
+	uiRamSegment = (ulFifoPtr & MSK_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM) >> SRT_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM;
+
+	/* set result */
+	*pptFrame = (ETHERNET_FRAME_T*)(s_apulIntRamStart[uiRamSegment] + (ETH_FRAME_BUF_SIZE * uiFrameIdx / sizeof(uint32_t)));
+	*phFrame  = (void*)ulFifoPtr;
+
+	return 0;
+}
+
+int netx4000_xceth_send_frame(unsigned int uiPort, void* hFrame, uint32_t ulLength, unsigned int uHighPriority)
+{
+	uint32_t ulFifoPtr = 0;
+	unsigned int uiFifo;
+	unsigned int uiXc  = uiPort >> 1;
+	unsigned int uiXpec = uiPort & 1;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if(uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+
+	if ((ulLength < ETHERNET_MINIMUM_FRAMELENGTH) || (ulLength > ETHERNET_MAXIMUM_FRAMELENGTH))
+		return -EINVAL;
+#endif
+
+	uiFifo  = uHighPriority ? ETHERNET_FIFO_REQ_HI : ETHERNET_FIFO_REQ_LO;
+	uiFifo += NUM_FIFO_CHANNELS_PER_UNIT * uiXpec;
+
+	/* create FIFO element */
+	ulFifoPtr = ((uint32_t)hFrame) & (MSK_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM | MSK_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM);
+
+	ulFifoPtr &= ~(MSK_ETHMAC_FIFO_ELEMENT_SUPPRESS_CON | MSK_ETHMAC_FIFO_ELEMENT_FRAME_LEN);
+	ulFifoPtr |= (ulLength << SRT_ETHMAC_FIFO_ELEMENT_FRAME_LEN);
+
+	/* request transmission by writing into according request FIFO */
+	iowrite32(ulFifoPtr, &s_aptPFifo[uiXc]->aulPfifo[uiFifo]);
+
+	return 0;
+}
+
+int netx4000_xceth_get_send_cnf_fill_level(unsigned int uiPort, unsigned int uHighPriority, uint32_t *pulCnfFillLevel)
+{
+	unsigned int uiFifo;
+	unsigned int uiXc   = uiPort >> 1;
+	unsigned int uiXpec = uiPort & 1;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if (uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+#endif
+
+	/* select FIFO based on priority selector */
+	uiFifo  = uHighPriority ? ETHERNET_FIFO_CON_HI : ETHERNET_FIFO_CON_LO;
+	uiFifo += NUM_FIFO_CHANNELS_PER_UNIT * uiXpec;
+
+	/* retrieve the current fill level from the selected FIFO */
+	*pulCnfFillLevel = ioread32(&s_aptPFifo[uiXc]->aulPfifo_fill_level[uiFifo]);
+
+	return 0;
+}
+
+int netx4000_xceth_get_send_cnf(unsigned int uiPort, ETHERNET_FRAME_T** pptFrame, void** phFrame, uint32_t* pulLength, unsigned int uHighPriority)
+{
+	unsigned int    uiFrameIdx;
+	unsigned int    uiRamSegment;
+	uint32_t        ulFillLevel;
+	unsigned int    uiFifo;
+	uint32_t        ulFifoPtr = 0;
+	uint32_t        ulVal;
+	unsigned int uiXc   = uiPort >> 1;
+	unsigned int uiXpec = uiPort & 1;
+	int rc;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if (uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+#endif
+
+	uiFifo  = uHighPriority ? ETHERNET_FIFO_CON_HI : ETHERNET_FIFO_CON_LO;
+	uiFifo += NUM_FIFO_CHANNELS_PER_UNIT * uiXpec;
+
+	rc = netx4000_xceth_get_send_cnf_fill_level(uiPort, uHighPriority, &ulFillLevel);
+	if (rc != 0)
+		return rc;
+
+	if (ulFillLevel == 0)
+		return -EBUSY;
+
+	/* retrieve the stored FIFO element */
+	ulFifoPtr = ioread32(&s_aptPFifo[uiXc]->aulPfifo[uiFifo]);
+
+	/* extract RAM bank and frame number */
+	uiFrameIdx   = (ulFifoPtr & MSK_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM) >> SRT_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM;
+	uiRamSegment = (ulFifoPtr & MSK_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM) >> SRT_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM;
+
+	/* set result */
+	*pptFrame = (ETHERNET_FRAME_T*)(s_apulIntRamStart[uiRamSegment] + ((uiFrameIdx * ETH_FRAME_BUF_SIZE) / sizeof(uint32_t)));
+	*phFrame  = (void*)ulFifoPtr;
+
+	/* retrieve the length from the FIFO element */
+	*pulLength = (ulFifoPtr & MSK_ETHMAC_FIFO_ELEMENT_FRAME_LEN) >> SRT_ETHMAC_FIFO_ELEMENT_FRAME_LEN;
+
+	/* decode the error code into our own version of it */
+	ulVal = (ulFifoPtr & MSK_ETHMAC_FIFO_ELEMENT_ERROR_CODE) >> SRT_ETHMAC_FIFO_ELEMENT_ERROR_CODE;
+
+	switch(ulVal) {
+	case CONF_ERRCODE_TX_SUCCESSFUL_WITHOUT_RETRIES:
+		rc = 0;
+		break;
+	case CONF_ERRCODE_TX_SUCCESSFUL_WITH_RETRIES:
+		rc = 0;
+		break;
+	case CONF_ERRCODE_TX_FAILED_LATE_COLLISION:
+		rc = -EIO;
+		break;
+	case CONF_ERRCODE_TX_FAILED_LINK_DOWN_DURING_TX:
+		rc = -EIO;
+		break;
+	case CONF_ERRCODE_TX_FAILED_EXCESSIVE_COLLISION:
+		rc = -EIO;
+		break;
+	case CONF_ERRCODE_TX_FAILED_UTX_UFL_DURING_TX:
+		rc = -EIO;
+		break;
+	case CONF_ERRCODE_TX_FAILED_FATAL_ERROR:
+		rc = -EIO;
+		break;
+	}
+
+	return rc;
+}
+
+int netx4000_xceth_send_frame_without_cnf(unsigned int uiPort, void* hFrame, uint32_t ulLength, unsigned int uHighPriority)
+{
+	uint32_t ulFifoPtr = 0;
+	unsigned int uiFifo;
+	unsigned int uiXc  = uiPort >> 1;
+	unsigned int uiXpec = uiPort & 1;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if (uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+
+	if ((ulLength < ETHERNET_MINIMUM_FRAMELENGTH) || (ulLength > ETHERNET_MAXIMUM_FRAMELENGTH))
+		return -EINVAL;
+#endif
+
+	uiFifo  = uHighPriority ? ETHERNET_FIFO_REQ_HI : ETHERNET_FIFO_REQ_LO;
+	uiFifo += NUM_FIFO_CHANNELS_PER_UNIT * uiXpec;
+
+	/* create FIFO element */
+	ulFifoPtr = ((uint32_t)hFrame) & (MSK_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM | MSK_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM);
+
+	ulFifoPtr |= MSK_ETHMAC_FIFO_ELEMENT_SUPPRESS_CON;
+	ulFifoPtr &= ~MSK_ETHMAC_FIFO_ELEMENT_FRAME_LEN;
+	ulFifoPtr |= (ulLength << SRT_ETHMAC_FIFO_ELEMENT_FRAME_LEN);
+
+	/* request transmission by writing into according request FIFO */
+	iowrite32(ulFifoPtr, &s_aptPFifo[uiXc]->aulPfifo[uiFifo]);
+
+	return 0;
+}
+
+/* RX */
+
+int netx4000_xceth_get_recv_fill_level(unsigned int uiPort, unsigned int uHighPriority, uint32_t *pulFillLevel)
+{
+	unsigned int uiFifo;
+	unsigned int uiXc  = uiPort >> 1;
+	unsigned int uiXpec = uiPort & 1;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if (uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+#endif
+
+	uiFifo  = uHighPriority ? ETHERNET_FIFO_IND_HI : ETHERNET_FIFO_IND_LO;
+	uiFifo += NUM_FIFO_CHANNELS_PER_UNIT * uiXpec;
+
+	/* get fill level of FIFO */
+	*pulFillLevel = ioread32(&s_aptPFifo[uiXc]->aulPfifo_fill_level[uiFifo]);
+
+	return 0;
+}
+
+int netx4000_xceth_recv_frame(unsigned int uiPort, ETHERNET_FRAME_T** pptFrame, void** phFrame, uint32_t* pulLength, unsigned int uHighPriority)
+{
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	uint32_t ulFillLevel;
+	int rc
+#endif
+	uint32_t ulOffset = 0;
+	uint32_t ulFifoPtr = 0;
+	uint32_t ulVal;
+	unsigned int uiFifo;
+	unsigned int uiXc  = uiPort >> 1;
+	unsigned int uiXpec = uiPort & 1;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if (uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+#endif
+
+	uiFifo  = uHighPriority ? ETHERNET_FIFO_IND_HI : ETHERNET_FIFO_IND_LO;
+	uiFifo += NUM_FIFO_CHANNELS_PER_UNIT * uiXpec;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* get current fill level from FIFO and check if there is at least one element */
+	rc = netx4000_xceth_get_recv_fill_level(uiPort, uHighPriority, &ulFillLevel);
+	if (rc)
+		return rc;
+
+	if (0 == ulFillLevel)
+		return -EBUSY;
+#endif
+
+	/* retrieve the FIFO element from the FIFO */
+	ulFifoPtr = ioread32(&s_aptPFifo[uiXc]->aulPfifo[uiFifo]);
+
+	ulVal = (ulFifoPtr & MSK_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM) >> SRT_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM;
+	ulOffset = ulVal * ETH_FRAME_BUF_SIZE;
+
+	/* set result */
+	ulVal = (ulFifoPtr & MSK_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM) >> SRT_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM;
+
+	*pptFrame = (ETHERNET_FRAME_T*)(s_apulIntRamStart[ulVal] + (ulOffset / sizeof(uint32_t)));
+	*pulLength = (ulFifoPtr & MSK_ETHMAC_FIFO_ELEMENT_FRAME_LEN) >> SRT_ETHMAC_FIFO_ELEMENT_FRAME_LEN;
+	*phFrame = (void*)ulFifoPtr;
+
+	return 0;
+}
+
+/* TX / RX */
+
+int netx4000_xceth_release_frame(unsigned int uiPort, void* hFrame)
+{
+	uint32_t ulFifoPtr = 0;
+	unsigned int uiFifo;
+	unsigned int uiXc  = uiPort >> 1;
+	unsigned int uiXpec = uiPort & 1;
+
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if (uiPort >= ETHMAC_PORTS)
+		return -EINVAL;
+#endif
+
+	uiFifo = ETHERNET_FIFO_EMPTY;
+	uiFifo += NUM_FIFO_CHANNELS_PER_UNIT * uiXpec;
+
+	/* clear all fields except buffer number and segment number in FIFO element */
+	ulFifoPtr = ((uint32_t)hFrame) & (MSK_ETHMAC_FIFO_ELEMENT_FRAME_BUF_NUM | MSK_ETHMAC_FIFO_ELEMENT_INT_RAM_SEGMENT_NUM);
+
+	/* return pointer in empty FIFO */
+	iowrite32(ulFifoPtr, &s_aptPFifo[uiXc]->aulPfifo[uiFifo]);
+
+	return 0;
+}
+
+int netx4000_xceth_mode_promisc(unsigned int uiPort, unsigned int uEnable)
+{
+#ifndef __ETHMAC_DISABLE_CHECKS__
+	/* check the port number */
+	if( uiPort >= ETHMAC_PORTS )
+		return -EINVAL;
+#endif
+	if (uEnable) {
+		iowrite32(MSK_ETHMAC_HELP_RX_FRWD2LOCAL, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_MONITORING_MODE);
+	}
+	else {
+		iowrite32(0, &s_aptXpecDRam[uiPort]->tETHMAC_CONFIG_AREA_BASE.ulETHMAC_MONITORING_MODE);
+	}
+
+	return 0;
+}
diff --git a/drivers/net/ethernet/netx4000/netx4000-xceth-hal.h b/drivers/net/ethernet/netx4000/netx4000-xceth-hal.h
new file mode 100644
index 000000000000..89c0054565a5
--- /dev/null
+++ b/drivers/net/ethernet/netx4000/netx4000-xceth-hal.h
@@ -0,0 +1,74 @@
+#ifndef __NETX4000_XCETH_H
+#define __NETX4000_XCETH_H
+
+#include "ethmac_xpec_regdef.h"
+
+#define __PACKED_PRE
+#define __PACKED_POST
+
+/*
+ * hal_ethmac.h
+ */
+
+/* MAC address structure */
+typedef uint8_t ETHERNET_MAC_ADDR_T[6];
+
+/*****************************************************************************/
+/*! MAC addresses
+* \description
+*    Describes the different types of MAC addresses.                         */
+/*****************************************************************************/
+typedef enum
+{
+  ETH_MAC_ADDRESS_CHASSIS,         /**< Primary Chassis MAC address */
+  ETH_MAC_ADDRESS_2ND_CHASSIS      /**< Secondary Chassis MAC address */
+} ETH_MAC_ADDRESS_TYPE_E;
+
+/*****************************************************************************/
+/*! Ethernet Frame Structure                                                 */
+/*****************************************************************************/
+typedef __PACKED_PRE struct ETHERNET_FRAME_Ttag
+{
+  ETHERNET_MAC_ADDR_T     tDstAddr;        /**< Destination MAC address (DA)      */
+  ETHERNET_MAC_ADDR_T     tSrcAddr;        /**< Source MAC address (SA)           */
+  uint16_t                usType;          /**< Frame length/type (LT)            */
+  uint8_t                 abData[1504];    /**< Frame data excluding DA,SA,LT,FCS */
+  uint8_t                 abRes[18];       /**< reserved, shall be zero           */
+  uint32_t                ulTimestampNs;   /**< receive time stamp [nanoseconds]  */
+  uint32_t                ulTimestampS;    /**< receive time stamp [s]            */
+} __PACKED_POST ETHERNET_FRAME_T;
+
+struct fifo_res {
+	uint8_t xcinst;
+	uint8_t xcNo;
+	uint8_t xcPortNo;
+};
+
+/* Prototypes */
+void netx4000_pfifo_reset(uint8_t xcNo);
+
+int netx4000_xceth_fifo_release(uint8_t xcinst);
+#ifdef __BAREBOX_CODE
+int netx4000_xceth_fifo_request(struct device_d *dev, uint8_t xcinst);
+#else
+int netx4000_xceth_fifo_request(struct device *dev, uint8_t xcinst);
+#endif
+
+void netx4000_xceth_initFifoUnit(unsigned int uiPort);
+int netx4000_xceth_set_link_mode(unsigned int uiPort, bool fValid, unsigned int uiSpeed, bool fFdx);
+int netx4000_xceth_set_mac_address(uint32_t uiPort, ETH_MAC_ADDRESS_TYPE_E eType, ETHERNET_MAC_ADDR_T tMacAddr);
+int netx4000_xceth_get_mac_address(uint32_t uiPort, ETH_MAC_ADDRESS_TYPE_E eType, ETHERNET_MAC_ADDR_T* ptMacAddr);
+int netx4000_xceth_get_frame(unsigned int uiPort, ETHERNET_FRAME_T** pptFrame, void** phFrame);
+int netx4000_xceth_send_frame(unsigned int uiPort, void* hFrame, uint32_t ulLength, unsigned int uHighPriority);
+int netx4000_xceth_get_send_cnf_fill_level(unsigned int uiPort, unsigned int uHighPriority, uint32_t *pulCnfFillLevel);
+int netx4000_xceth_get_send_cnf(unsigned int uiPort, ETHERNET_FRAME_T** pptFrame, void** phFrame, uint32_t* pulLength, unsigned int uHighPriority);
+int netx4000_xceth_send_frame_without_cnf(unsigned int uiPort, void* hFrame, uint32_t ulLength, unsigned int uHighPriority);
+int netx4000_xceth_get_recv_fill_level(unsigned int uiPort, unsigned int uHighPriority, uint32_t *pulFillLevel);
+int netx4000_xceth_recv_frame(unsigned int uiPort, ETHERNET_FRAME_T** pptFrame, void** phFrame, uint32_t* pulLength, unsigned int uHighPriority);
+int netx4000_xceth_release_frame(unsigned int uiPort, void* hFrame);
+int netx4000_xceth_set_irq(uint8_t xcinst, uint32_t mask);
+uint32_t netx4000_xceth_get_irq(uint8_t port);
+void netx4000_xceth_confirm_irq(uint8_t port, uint32_t mask);
+int netx4000_xceth_mode_promisc(unsigned int uiPort, unsigned int uEnable );
+
+#endif
\ No newline at end of file
-- 
2.25.1

